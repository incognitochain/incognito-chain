package rpcserver

import (
	"github.com/internet-cash/prototype/blockchain"
	"sync/atomic"
	"net/http"
	"errors"
	"time"
	"log"
)

const (
	rpcAuthTimeoutSeconds = 10
)

type commandHandler func(*RpcServer, interface{}, <-chan struct{}) (interface{}, error)

var RpcHandler = map[string]commandHandler{
	"createtransaction": handleCreateTransaction,
}

// rpcServer provides a concurrent safe RPC server to a chain server.
type RpcServer struct {
	started    int32
	shutdown   int32
	numClients int32

	Config     RpcServerConfig
	HttpServer *http.Server

	requestProcessShutdown chan struct{}
	quit                   chan int
}

type RpcServerConfig struct {
	ChainParams   *blockchain.Params
	RPCMaxClients int
	Port          string
}

func (self RpcServer) Init(config *RpcServerConfig) (*RpcServer, error) {
	self.Config = *config
	return &self, nil
}

// RequestedProcessShutdown returns a channel that is sent to when an authorized
// RPC client requests the process to shutdown.  If the request can not be read
// immediately, it is dropped.
func (self RpcServer) RequestedProcessShutdown() <-chan struct{} {
	return self.requestProcessShutdown
}

// limitConnections responds with a 503 service unavailable and returns true if
// adding another client would exceed the maximum allow RPC clients.
//
// This function is safe for concurrent access.
func (self RpcServer) limitConnections(w http.ResponseWriter, remoteAddr string) bool {
	if int(atomic.LoadInt32(&self.numClients)+1) > self.Config.RPCMaxClients {
		log.Printf("Max RPC clients exceeded [%d] - "+
			"disconnecting client %s", self.Config.RPCMaxClients,
			remoteAddr)
		http.Error(w, "503 Too busy.  Try again later.",
			http.StatusServiceUnavailable)
		return true
	}
	return false
}

// genCertPair generates a key/cert pair to the paths provided.
func genCertPair(certFile, keyFile string) error {
	// TODO for using TCL
	/*log.Println("Generating TLS certificates...")

	org := "btcd autogenerated cert"
	validUntil := time.Now().Add(10 * 365 * 24 * time.Hour)
	cert, key, err := btcutil.NewTLSCertPair(org, validUntil, nil)
	if err != nil {
		return err
	}

	// Write cert and key files.
	if err = ioutil.WriteFile(certFile, cert, 0666); err != nil {
		return err
	}
	if err = ioutil.WriteFile(keyFile, key, 0600); err != nil {
		os.Remove(certFile)
		return err
	}

	rpcsLog.Infof("Done generating TLS certificates")*/
	return nil
}

func (self RpcServer) Start() (error) {
	if atomic.AddInt32(&self.started, 1) != 1 {
		return errors.New("RPC server is already started")
	}
	rpcServeMux := http.NewServeMux()
	self.HttpServer = &http.Server{
		Addr:    ":" + self.Config.Port,
		Handler: rpcServeMux,

		// Timeout connections which don't complete the initial
		// handshake within the allowed timeframe.
		ReadTimeout: time.Second * rpcAuthTimeoutSeconds,
	}

	rpcServeMux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Connection", "close")
		w.Header().Set("Content-Type", "application/json")
		r.Close = true
	})
	self.HttpServer.ListenAndServe()
	return nil
}

// Stop is used by server.go to stop the rpc listener.
func (self RpcServer) Stop() error {
	if atomic.AddInt32(&self.shutdown, 1) != 1 {
		rpcsLog.Infof("RPC server is already in the process of shutting down")
		return nil
	}
	log.Println("RPC server shutting down")
	self.HttpServer.Close()
	close(self.quit)
	log.Println("RPC server shutdown complete")
	return nil
}

func handleCreateTransaction(self *RpcServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	return nil, nil
}
