// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import big "math/big"
import common "github.com/incognitochain/incognito-chain/common"
import database "github.com/incognitochain/incognito-chain/database"
import mock "github.com/stretchr/testify/mock"

// DatabaseInterface is an autogenerated mock type for the DatabaseInterface type
type DatabaseInterface struct {
	mock.Mock
}

// AddCommitteeReward provides a mock function with given fields: committeeAddress, amount, tokenID
func (_m *DatabaseInterface) AddCommitteeReward(committeeAddress []byte, amount uint64, tokenID common.Hash) error {
	ret := _m.Called(committeeAddress, amount, tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, uint64, common.Hash) error); ok {
		r0 = rf(committeeAddress, amount, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddShardRewardRequest provides a mock function with given fields: epoch, shardID, amount, tokenID
func (_m *DatabaseInterface) AddShardRewardRequest(epoch uint64, shardID byte, amount uint64, tokenID common.Hash) error {
	ret := _m.Called(epoch, shardID, amount, tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, byte, uint64, common.Hash) error); ok {
		r0 = rf(epoch, shardID, amount, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackupBridgedTokenByTokenID provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) BackupBridgedTokenByTokenID(tokenID common.Hash) error {
	ret := _m.Called(tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash) error); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackupCommitmentsOfPubkey provides a mock function with given fields: tokenID, shardID, pubkey
func (_m *DatabaseInterface) BackupCommitmentsOfPubkey(tokenID common.Hash, shardID byte, pubkey []byte) error {
	ret := _m.Called(tokenID, shardID, pubkey)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, byte, []byte) error); ok {
		r0 = rf(tokenID, shardID, pubkey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackupCommitteeReward provides a mock function with given fields: committeeAddress, tokenID
func (_m *DatabaseInterface) BackupCommitteeReward(committeeAddress []byte, tokenID common.Hash) error {
	ret := _m.Called(committeeAddress, tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, common.Hash) error); ok {
		r0 = rf(committeeAddress, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackupSerialNumbersLen provides a mock function with given fields: tokenID, shardID
func (_m *DatabaseInterface) BackupSerialNumbersLen(tokenID common.Hash, shardID byte) error {
	ret := _m.Called(tokenID, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, byte) error); ok {
		r0 = rf(tokenID, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackupShardRewardRequest provides a mock function with given fields: epoch, shardID, tokenID
func (_m *DatabaseInterface) BackupShardRewardRequest(epoch uint64, shardID byte, tokenID common.Hash) error {
	ret := _m.Called(epoch, shardID, tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, byte, common.Hash) error); ok {
		r0 = rf(epoch, shardID, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CanProcessCIncToken provides a mock function with given fields: incTokenID
func (_m *DatabaseInterface) CanProcessCIncToken(incTokenID common.Hash) (bool, error) {
	ret := _m.Called(incTokenID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(incTokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(incTokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CanProcessTokenPair provides a mock function with given fields: externalTokenID, incTokenID
func (_m *DatabaseInterface) CanProcessTokenPair(externalTokenID []byte, incTokenID common.Hash) (bool, error) {
	ret := _m.Called(externalTokenID, incTokenID)

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte, common.Hash) bool); ok {
		r0 = rf(externalTokenID, incTokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, common.Hash) error); ok {
		r1 = rf(externalTokenID, incTokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CleanBackup provides a mock function with given fields: isBeacon, shardID
func (_m *DatabaseInterface) CleanBackup(isBeacon bool, shardID byte) error {
	ret := _m.Called(isBeacon, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(bool, byte) error); ok {
		r0 = rf(isBeacon, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanBeaconBestState provides a mock function with given fields:
func (_m *DatabaseInterface) CleanBeaconBestState() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanCommitments provides a mock function with given fields:
func (_m *DatabaseInterface) CleanCommitments() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanFeeEstimator provides a mock function with given fields:
func (_m *DatabaseInterface) CleanFeeEstimator() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanSNDerivator provides a mock function with given fields:
func (_m *DatabaseInterface) CleanSNDerivator() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanSerialNumbers provides a mock function with given fields:
func (_m *DatabaseInterface) CleanSerialNumbers() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanShardBestState provides a mock function with given fields:
func (_m *DatabaseInterface) CleanShardBestState() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *DatabaseInterface) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: key
func (_m *DatabaseInterface) Delete(key []byte) error {
	ret := _m.Called(key)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteAcceptedShardToBeacon provides a mock function with given fields: shardID, shardBlkHash
func (_m *DatabaseInterface) DeleteAcceptedShardToBeacon(shardID byte, shardBlkHash common.Hash) error {
	ret := _m.Called(shardID, shardBlkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, common.Hash) error); ok {
		r0 = rf(shardID, shardBlkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBeaconBlock provides a mock function with given fields: hash, idx
func (_m *DatabaseInterface) DeleteBeaconBlock(hash common.Hash, idx uint64) error {
	ret := _m.Called(hash, idx)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, uint64) error); ok {
		r0 = rf(hash, idx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBlock provides a mock function with given fields: hash, idx, shardID
func (_m *DatabaseInterface) DeleteBlock(hash common.Hash, idx uint64, shardID byte) error {
	ret := _m.Called(hash, idx, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, uint64, byte) error); ok {
		r0 = rf(hash, idx, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteCommitteeByHeight provides a mock function with given fields: _a0
func (_m *DatabaseInterface) DeleteCommitteeByHeight(_a0 uint64) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteIncomingCrossShard provides a mock function with given fields: shardID, crossShardID, crossBlkHash
func (_m *DatabaseInterface) DeleteIncomingCrossShard(shardID byte, crossShardID byte, crossBlkHash common.Hash) error {
	ret := _m.Called(shardID, crossShardID, crossBlkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, byte, common.Hash) error); ok {
		r0 = rf(shardID, crossShardID, crossBlkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNormalToken provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) DeleteNormalToken(tokenID common.Hash) error {
	ret := _m.Called(tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash) error); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNormalTokenTx provides a mock function with given fields: tokenID, txIndex, shardID, blockHeight
func (_m *DatabaseInterface) DeleteNormalTokenTx(tokenID common.Hash, txIndex int32, shardID byte, blockHeight uint64) error {
	ret := _m.Called(tokenID, txIndex, shardID, blockHeight)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, int32, byte, uint64) error); ok {
		r0 = rf(tokenID, txIndex, shardID, blockHeight)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteOutputCoin provides a mock function with given fields: tokenID, publicKey, outputCoinArr, shardID
func (_m *DatabaseInterface) DeleteOutputCoin(tokenID common.Hash, publicKey []byte, outputCoinArr [][]byte, shardID byte) error {
	ret := _m.Called(tokenID, publicKey, outputCoinArr, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, [][]byte, byte) error); ok {
		r0 = rf(tokenID, publicKey, outputCoinArr, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePrivacyToken provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) DeletePrivacyToken(tokenID common.Hash) error {
	ret := _m.Called(tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash) error); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePrivacyTokenCrossShard provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) DeletePrivacyTokenCrossShard(tokenID common.Hash) error {
	ret := _m.Called(tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash) error); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePrivacyTokenTx provides a mock function with given fields: tokenID, txIndex, shardID, blockHeight
func (_m *DatabaseInterface) DeletePrivacyTokenTx(tokenID common.Hash, txIndex int32, shardID byte, blockHeight uint64) error {
	ret := _m.Called(tokenID, txIndex, shardID, blockHeight)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, int32, byte, uint64) error); ok {
		r0 = rf(tokenID, txIndex, shardID, blockHeight)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTransactionIndex provides a mock function with given fields: txId
func (_m *DatabaseInterface) DeleteTransactionIndex(txId common.Hash) error {
	ret := _m.Called(txId)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash) error); ok {
		r0 = rf(txId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FetchBeaconBestState provides a mock function with given fields:
func (_m *DatabaseInterface) FetchBeaconBestState() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchBeaconBlock provides a mock function with given fields: hash
func (_m *DatabaseInterface) FetchBeaconBlock(hash common.Hash) ([]byte, error) {
	ret := _m.Called(hash)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(common.Hash) []byte); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchBeaconCommitteeByHeight provides a mock function with given fields: _a0
func (_m *DatabaseInterface) FetchBeaconCommitteeByHeight(_a0 uint64) ([]byte, error) {
	ret := _m.Called(_a0)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint64) []byte); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchBlock provides a mock function with given fields: hash
func (_m *DatabaseInterface) FetchBlock(hash common.Hash) ([]byte, error) {
	ret := _m.Called(hash)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(common.Hash) []byte); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchCrossShardNextHeight provides a mock function with given fields: fromShard, toShard, curHeight
func (_m *DatabaseInterface) FetchCrossShardNextHeight(fromShard byte, toShard byte, curHeight uint64) (uint64, error) {
	ret := _m.Called(fromShard, toShard, curHeight)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(byte, byte, uint64) uint64); ok {
		r0 = rf(fromShard, toShard, curHeight)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(byte, byte, uint64) error); ok {
		r1 = rf(fromShard, toShard, curHeight)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchPrevBestState provides a mock function with given fields: isBeacon, shardID
func (_m *DatabaseInterface) FetchPrevBestState(isBeacon bool, shardID byte) ([]byte, error) {
	ret := _m.Called(isBeacon, shardID)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(bool, byte) []byte); ok {
		r0 = rf(isBeacon, shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(bool, byte) error); ok {
		r1 = rf(isBeacon, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchRewardReceiverByHeight provides a mock function with given fields: _a0
func (_m *DatabaseInterface) FetchRewardReceiverByHeight(_a0 uint64) ([]byte, error) {
	ret := _m.Called(_a0)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint64) []byte); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchShardBestState provides a mock function with given fields: shardID
func (_m *DatabaseInterface) FetchShardBestState(shardID byte) ([]byte, error) {
	ret := _m.Called(shardID)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(byte) []byte); ok {
		r0 = rf(shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(byte) error); ok {
		r1 = rf(shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchShardCommitteeByHeight provides a mock function with given fields: _a0
func (_m *DatabaseInterface) FetchShardCommitteeByHeight(_a0 uint64) ([]byte, error) {
	ret := _m.Called(_a0)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint64) []byte); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: key
func (_m *DatabaseInterface) Get(key []byte) ([]byte, error) {
	ret := _m.Called(key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAcceptedShardToBeacon provides a mock function with given fields: shardID, shardBlkHash
func (_m *DatabaseInterface) GetAcceptedShardToBeacon(shardID byte, shardBlkHash common.Hash) (uint64, error) {
	ret := _m.Called(shardID, shardBlkHash)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(byte, common.Hash) uint64); ok {
		r0 = rf(shardID, shardBlkHash)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(byte, common.Hash) error); ok {
		r1 = rf(shardID, shardBlkHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllBridgeTokens provides a mock function with given fields:
func (_m *DatabaseInterface) GetAllBridgeTokens() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBeaconBlockHashByIndex provides a mock function with given fields: idx
func (_m *DatabaseInterface) GetBeaconBlockHashByIndex(idx uint64) (common.Hash, error) {
	ret := _m.Called(idx)

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(uint64) common.Hash); ok {
		r0 = rf(idx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(idx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByIndex provides a mock function with given fields: idx, shardID
func (_m *DatabaseInterface) GetBlockByIndex(idx uint64, shardID byte) (common.Hash, error) {
	ret := _m.Called(idx, shardID)

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(uint64, byte) common.Hash); ok {
		r0 = rf(idx, shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, byte) error); ok {
		r1 = rf(idx, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBridgeReqWithStatus provides a mock function with given fields: txReqID
func (_m *DatabaseInterface) GetBridgeReqWithStatus(txReqID common.Hash) (byte, error) {
	ret := _m.Called(txReqID)

	var r0 byte
	if rf, ok := ret.Get(0).(func(common.Hash) byte); ok {
		r0 = rf(txReqID)
	} else {
		r0 = ret.Get(0).(byte)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(txReqID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBurningConfirm provides a mock function with given fields: txID
func (_m *DatabaseInterface) GetBurningConfirm(txID common.Hash) (uint64, error) {
	ret := _m.Called(txID)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(common.Hash) uint64); ok {
		r0 = rf(txID)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(txID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitmentByIndex provides a mock function with given fields: tokenID, commitmentIndex, shardID
func (_m *DatabaseInterface) GetCommitmentByIndex(tokenID common.Hash, commitmentIndex uint64, shardID byte) ([]byte, error) {
	ret := _m.Called(tokenID, commitmentIndex, shardID)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(common.Hash, uint64, byte) []byte); ok {
		r0 = rf(tokenID, commitmentIndex, shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, uint64, byte) error); ok {
		r1 = rf(tokenID, commitmentIndex, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitmentIndex provides a mock function with given fields: tokenID, commitment, shardID
func (_m *DatabaseInterface) GetCommitmentIndex(tokenID common.Hash, commitment []byte, shardID byte) (*big.Int, error) {
	ret := _m.Called(tokenID, commitment, shardID)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, byte) *big.Int); ok {
		r0 = rf(tokenID, commitment, shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, []byte, byte) error); ok {
		r1 = rf(tokenID, commitment, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitmentLength provides a mock function with given fields: tokenID, shardID
func (_m *DatabaseInterface) GetCommitmentLength(tokenID common.Hash, shardID byte) (*big.Int, error) {
	ret := _m.Called(tokenID, shardID)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(common.Hash, byte) *big.Int); ok {
		r0 = rf(tokenID, shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, byte) error); ok {
		r1 = rf(tokenID, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitteeReward provides a mock function with given fields: committeeAddress, tokenID
func (_m *DatabaseInterface) GetCommitteeReward(committeeAddress []byte, tokenID common.Hash) (uint64, error) {
	ret := _m.Called(committeeAddress, tokenID)

	var r0 uint64
	if rf, ok := ret.Get(0).(func([]byte, common.Hash) uint64); ok {
		r0 = rf(committeeAddress, tokenID)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, common.Hash) error); ok {
		r1 = rf(committeeAddress, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFeeEstimator provides a mock function with given fields: shardID
func (_m *DatabaseInterface) GetFeeEstimator(shardID byte) ([]byte, error) {
	ret := _m.Called(shardID)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(byte) []byte); ok {
		r0 = rf(shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(byte) error); ok {
		r1 = rf(shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIncomingCrossShard provides a mock function with given fields: shardID, crossShardID, crossBlkHash
func (_m *DatabaseInterface) GetIncomingCrossShard(shardID byte, crossShardID byte, crossBlkHash common.Hash) (uint64, error) {
	ret := _m.Called(shardID, crossShardID, crossBlkHash)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(byte, byte, common.Hash) uint64); ok {
		r0 = rf(shardID, crossShardID, crossBlkHash)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(byte, byte, common.Hash) error); ok {
		r1 = rf(shardID, crossShardID, crossBlkHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIndexOfBeaconBlock provides a mock function with given fields: hash
func (_m *DatabaseInterface) GetIndexOfBeaconBlock(hash common.Hash) (uint64, error) {
	ret := _m.Called(hash)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(common.Hash) uint64); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIndexOfBlock provides a mock function with given fields: hash
func (_m *DatabaseInterface) GetIndexOfBlock(hash common.Hash) (uint64, byte, error) {
	ret := _m.Called(hash)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(common.Hash) uint64); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 byte
	if rf, ok := ret.Get(1).(func(common.Hash) byte); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Get(1).(byte)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(common.Hash) error); ok {
		r2 = rf(hash)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNormalTokenPaymentAddressUTXO provides a mock function with given fields: tokenID, paymentAddress
func (_m *DatabaseInterface) GetNormalTokenPaymentAddressUTXO(tokenID common.Hash, paymentAddress []byte) (map[string]string, error) {
	ret := _m.Called(tokenID, paymentAddress)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(common.Hash, []byte) map[string]string); ok {
		r0 = rf(tokenID, paymentAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, []byte) error); ok {
		r1 = rf(tokenID, paymentAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNormalTokenPaymentAddressesBalance provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) GetNormalTokenPaymentAddressesBalance(tokenID common.Hash) (map[string]uint64, error) {
	ret := _m.Called(tokenID)

	var r0 map[string]uint64
	if rf, ok := ret.Get(0).(func(common.Hash) map[string]uint64); ok {
		r0 = rf(tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]uint64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutcoinsByPubkey provides a mock function with given fields: tokenID, pubkey, shardID
func (_m *DatabaseInterface) GetOutcoinsByPubkey(tokenID common.Hash, pubkey []byte, shardID byte) ([][]byte, error) {
	ret := _m.Called(tokenID, pubkey, shardID)

	var r0 [][]byte
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, byte) [][]byte); ok {
		r0 = rf(tokenID, pubkey, shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, []byte, byte) error); ok {
		r1 = rf(tokenID, pubkey, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRewardOfShardByEpoch provides a mock function with given fields: epoch, shardID, tokenID
func (_m *DatabaseInterface) GetRewardOfShardByEpoch(epoch uint64, shardID byte, tokenID common.Hash) (uint64, error) {
	ret := _m.Called(epoch, shardID, tokenID)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(uint64, byte, common.Hash) uint64); ok {
		r0 = rf(epoch, shardID, tokenID)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, byte, common.Hash) error); ok {
		r1 = rf(epoch, shardID, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionIndexById provides a mock function with given fields: txId
func (_m *DatabaseInterface) GetTransactionIndexById(txId common.Hash) (common.Hash, int, error) {
	ret := _m.Called(txId)

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(common.Hash) common.Hash); ok {
		r0 = rf(txId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(common.Hash) int); ok {
		r1 = rf(txId)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(common.Hash) error); ok {
		r2 = rf(txId)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTxByPublicKey provides a mock function with given fields: publicKey
func (_m *DatabaseInterface) GetTxByPublicKey(publicKey []byte) (map[byte][]common.Hash, error) {
	ret := _m.Called(publicKey)

	var r0 map[byte][]common.Hash
	if rf, ok := ret.Get(0).(func([]byte) map[byte][]common.Hash); ok {
		r0 = rf(publicKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[byte][]common.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(publicKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasAcceptedShardToBeacon provides a mock function with given fields: shardID, shardBlkHash
func (_m *DatabaseInterface) HasAcceptedShardToBeacon(shardID byte, shardBlkHash common.Hash) error {
	ret := _m.Called(shardID, shardBlkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, common.Hash) error); ok {
		r0 = rf(shardID, shardBlkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HasBeaconBlock provides a mock function with given fields: hash
func (_m *DatabaseInterface) HasBeaconBlock(hash common.Hash) (bool, error) {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasBlock provides a mock function with given fields: hash
func (_m *DatabaseInterface) HasBlock(hash common.Hash) (bool, error) {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasCommitment provides a mock function with given fields: tokenID, commitment, shardID
func (_m *DatabaseInterface) HasCommitment(tokenID common.Hash, commitment []byte, shardID byte) (bool, error) {
	ret := _m.Called(tokenID, commitment, shardID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, byte) bool); ok {
		r0 = rf(tokenID, commitment, shardID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, []byte, byte) error); ok {
		r1 = rf(tokenID, commitment, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasCommitmentIndex provides a mock function with given fields: tokenID, commitmentIndex, shardID
func (_m *DatabaseInterface) HasCommitmentIndex(tokenID common.Hash, commitmentIndex uint64, shardID byte) (bool, error) {
	ret := _m.Called(tokenID, commitmentIndex, shardID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash, uint64, byte) bool); ok {
		r0 = rf(tokenID, commitmentIndex, shardID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, uint64, byte) error); ok {
		r1 = rf(tokenID, commitmentIndex, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasCommitteeByHeight provides a mock function with given fields: _a0
func (_m *DatabaseInterface) HasCommitteeByHeight(_a0 uint64) (bool, error) {
	ret := _m.Called(_a0)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasIncomingCrossShard provides a mock function with given fields: shardID, crossShardID, crossBlkHash
func (_m *DatabaseInterface) HasIncomingCrossShard(shardID byte, crossShardID byte, crossBlkHash common.Hash) error {
	ret := _m.Called(shardID, crossShardID, crossBlkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, byte, common.Hash) error); ok {
		r0 = rf(shardID, crossShardID, crossBlkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HasSNDerivator provides a mock function with given fields: tokenID, data, shardID
func (_m *DatabaseInterface) HasSNDerivator(tokenID common.Hash, data []byte, shardID byte) (bool, error) {
	ret := _m.Called(tokenID, data, shardID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, byte) bool); ok {
		r0 = rf(tokenID, data, shardID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, []byte, byte) error); ok {
		r1 = rf(tokenID, data, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasSerialNumber provides a mock function with given fields: tokenID, data, shardID
func (_m *DatabaseInterface) HasSerialNumber(tokenID common.Hash, data []byte, shardID byte) (bool, error) {
	ret := _m.Called(tokenID, data, shardID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, byte) bool); ok {
		r0 = rf(tokenID, data, shardID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, []byte, byte) error); ok {
		r1 = rf(tokenID, data, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasValue provides a mock function with given fields: key
func (_m *DatabaseInterface) HasValue(key []byte) (bool, error) {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertETHTxHashIssued provides a mock function with given fields: uniqETHTx
func (_m *DatabaseInterface) InsertETHTxHashIssued(uniqETHTx []byte) error {
	ret := _m.Called(uniqETHTx)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(uniqETHTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsBridgeTokenExistedByType provides a mock function with given fields: incTokenID, isCentralized
func (_m *DatabaseInterface) IsBridgeTokenExistedByType(incTokenID common.Hash, isCentralized bool) (bool, error) {
	ret := _m.Called(incTokenID, isCentralized)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash, bool) bool); ok {
		r0 = rf(incTokenID, isCentralized)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, bool) error); ok {
		r1 = rf(incTokenID, isCentralized)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsETHTxHashIssued provides a mock function with given fields: uniqETHTx
func (_m *DatabaseInterface) IsETHTxHashIssued(uniqETHTx []byte) (bool, error) {
	ret := _m.Called(uniqETHTx)

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(uniqETHTx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(uniqETHTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCommitteeReward provides a mock function with given fields:
func (_m *DatabaseInterface) ListCommitteeReward() map[string]map[common.Hash]uint64 {
	ret := _m.Called()

	var r0 map[string]map[common.Hash]uint64
	if rf, ok := ret.Get(0).(func() map[string]map[common.Hash]uint64); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]map[common.Hash]uint64)
		}
	}

	return r0
}

// ListNormalToken provides a mock function with given fields:
func (_m *DatabaseInterface) ListNormalToken() ([][]byte, error) {
	ret := _m.Called()

	var r0 [][]byte
	if rf, ok := ret.Get(0).(func() [][]byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPrivacyToken provides a mock function with given fields:
func (_m *DatabaseInterface) ListPrivacyToken() ([][]byte, error) {
	ret := _m.Called()

	var r0 [][]byte
	if rf, ok := ret.Get(0).(func() [][]byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPrivacyTokenCrossShard provides a mock function with given fields:
func (_m *DatabaseInterface) ListPrivacyTokenCrossShard() ([][]byte, error) {
	ret := _m.Called()

	var r0 [][]byte
	if rf, ok := ret.Get(0).(func() [][]byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSerialNumber provides a mock function with given fields: tokenID, shardID
func (_m *DatabaseInterface) ListSerialNumber(tokenID common.Hash, shardID byte) (map[string]uint64, error) {
	ret := _m.Called(tokenID, shardID)

	var r0 map[string]uint64
	if rf, ok := ret.Get(0).(func(common.Hash, byte) map[string]uint64); ok {
		r0 = rf(tokenID, shardID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]uint64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash, byte) error); ok {
		r1 = rf(tokenID, shardID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NormalTokenIDExisted provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) NormalTokenIDExisted(tokenID common.Hash) bool {
	ret := _m.Called(tokenID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// NormalTokenTxs provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) NormalTokenTxs(tokenID common.Hash) ([]common.Hash, error) {
	ret := _m.Called(tokenID)

	var r0 []common.Hash
	if rf, ok := ret.Get(0).(func(common.Hash) []common.Hash); ok {
		r0 = rf(tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrivacyTokenIDCrossShardExisted provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) PrivacyTokenIDCrossShardExisted(tokenID common.Hash) bool {
	ret := _m.Called(tokenID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// PrivacyTokenIDExisted provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) PrivacyTokenIDExisted(tokenID common.Hash) bool {
	ret := _m.Called(tokenID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// PrivacyTokenTxs provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) PrivacyTokenTxs(tokenID common.Hash) ([]common.Hash, error) {
	ret := _m.Called(tokenID)

	var r0 []common.Hash
	if rf, ok := ret.Get(0).(func(common.Hash) []common.Hash); ok {
		r0 = rf(tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Put provides a mock function with given fields: key, value
func (_m *DatabaseInterface) Put(key []byte, value []byte) error {
	ret := _m.Called(key, value)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = rf(key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PutBatch provides a mock function with given fields: data
func (_m *DatabaseInterface) PutBatch(data []database.BatchData) error {
	ret := _m.Called(data)

	var r0 error
	if rf, ok := ret.Get(0).(func([]database.BatchData) error); ok {
		r0 = rf(data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveCommitteeReward provides a mock function with given fields: committeeAddress, amount, tokenID
func (_m *DatabaseInterface) RemoveCommitteeReward(committeeAddress []byte, amount uint64, tokenID common.Hash) error {
	ret := _m.Called(committeeAddress, amount, tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, uint64, common.Hash) error); ok {
		r0 = rf(committeeAddress, amount, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestoreBridgedTokenByTokenID provides a mock function with given fields: tokenID
func (_m *DatabaseInterface) RestoreBridgedTokenByTokenID(tokenID common.Hash) error {
	ret := _m.Called(tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash) error); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestoreCommitmentsOfPubkey provides a mock function with given fields: tokenID, shardID, pubkey, commitments
func (_m *DatabaseInterface) RestoreCommitmentsOfPubkey(tokenID common.Hash, shardID byte, pubkey []byte, commitments [][]byte) error {
	ret := _m.Called(tokenID, shardID, pubkey, commitments)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, byte, []byte, [][]byte) error); ok {
		r0 = rf(tokenID, shardID, pubkey, commitments)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestoreCommitteeReward provides a mock function with given fields: committeeAddress, tokenID
func (_m *DatabaseInterface) RestoreCommitteeReward(committeeAddress []byte, tokenID common.Hash) error {
	ret := _m.Called(committeeAddress, tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, common.Hash) error); ok {
		r0 = rf(committeeAddress, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestoreCrossShardNextHeights provides a mock function with given fields: fromShard, toShard, curHeight
func (_m *DatabaseInterface) RestoreCrossShardNextHeights(fromShard byte, toShard byte, curHeight uint64) error {
	ret := _m.Called(fromShard, toShard, curHeight)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, byte, uint64) error); ok {
		r0 = rf(fromShard, toShard, curHeight)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestoreSerialNumber provides a mock function with given fields: tokenID, shardID, serialNumbers
func (_m *DatabaseInterface) RestoreSerialNumber(tokenID common.Hash, shardID byte, serialNumbers [][]byte) error {
	ret := _m.Called(tokenID, shardID, serialNumbers)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, byte, [][]byte) error); ok {
		r0 = rf(tokenID, shardID, serialNumbers)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestoreShardRewardRequest provides a mock function with given fields: epoch, shardID, tokenID
func (_m *DatabaseInterface) RestoreShardRewardRequest(epoch uint64, shardID byte, tokenID common.Hash) error {
	ret := _m.Called(epoch, shardID, tokenID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, byte, common.Hash) error); ok {
		r0 = rf(epoch, shardID, tokenID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreAcceptedShardToBeacon provides a mock function with given fields: shardID, blkHeight, shardBlkHash
func (_m *DatabaseInterface) StoreAcceptedShardToBeacon(shardID byte, blkHeight uint64, shardBlkHash common.Hash) error {
	ret := _m.Called(shardID, blkHeight, shardBlkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, uint64, common.Hash) error); ok {
		r0 = rf(shardID, blkHeight, shardBlkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreBeaconBestState provides a mock function with given fields: v
func (_m *DatabaseInterface) StoreBeaconBestState(v interface{}) error {
	ret := _m.Called(v)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreBeaconBlock provides a mock function with given fields: v, hash
func (_m *DatabaseInterface) StoreBeaconBlock(v interface{}, hash common.Hash) error {
	ret := _m.Called(v, hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, common.Hash) error); ok {
		r0 = rf(v, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreBeaconBlockIndex provides a mock function with given fields: hash, idx
func (_m *DatabaseInterface) StoreBeaconBlockIndex(hash common.Hash, idx uint64) error {
	ret := _m.Called(hash, idx)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, uint64) error); ok {
		r0 = rf(hash, idx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreBeaconCommitteeByHeight provides a mock function with given fields: _a0, _a1
func (_m *DatabaseInterface) StoreBeaconCommitteeByHeight(_a0 uint64, _a1 interface{}) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, interface{}) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreBurningConfirm provides a mock function with given fields: txID, height
func (_m *DatabaseInterface) StoreBurningConfirm(txID common.Hash, height uint64) error {
	ret := _m.Called(txID, height)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, uint64) error); ok {
		r0 = rf(txID, height)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreCommitments provides a mock function with given fields: tokenID, pubkey, commitment, shardID
func (_m *DatabaseInterface) StoreCommitments(tokenID common.Hash, pubkey []byte, commitment [][]byte, shardID byte) error {
	ret := _m.Called(tokenID, pubkey, commitment, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, [][]byte, byte) error); ok {
		r0 = rf(tokenID, pubkey, commitment, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreCrossShardNextHeight provides a mock function with given fields: fromShard, toShard, curHeight, nextHeight
func (_m *DatabaseInterface) StoreCrossShardNextHeight(fromShard byte, toShard byte, curHeight uint64, nextHeight uint64) error {
	ret := _m.Called(fromShard, toShard, curHeight, nextHeight)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, byte, uint64, uint64) error); ok {
		r0 = rf(fromShard, toShard, curHeight, nextHeight)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreFeeEstimator provides a mock function with given fields: val, shardID
func (_m *DatabaseInterface) StoreFeeEstimator(val []byte, shardID byte) error {
	ret := _m.Called(val, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, byte) error); ok {
		r0 = rf(val, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreIncomingCrossShard provides a mock function with given fields: shardID, crossShardID, blkHeight, crossBlkHash
func (_m *DatabaseInterface) StoreIncomingCrossShard(shardID byte, crossShardID byte, blkHeight uint64, crossBlkHash common.Hash) error {
	ret := _m.Called(shardID, crossShardID, blkHeight, crossBlkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(byte, byte, uint64, common.Hash) error); ok {
		r0 = rf(shardID, crossShardID, blkHeight, crossBlkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreNormalToken provides a mock function with given fields: tokenID, data
func (_m *DatabaseInterface) StoreNormalToken(tokenID common.Hash, data []byte) error {
	ret := _m.Called(tokenID, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, []byte) error); ok {
		r0 = rf(tokenID, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreNormalTokenTx provides a mock function with given fields: tokenID, shardID, blockHeight, txIndex, data
func (_m *DatabaseInterface) StoreNormalTokenTx(tokenID common.Hash, shardID byte, blockHeight uint64, txIndex int32, data []byte) error {
	ret := _m.Called(tokenID, shardID, blockHeight, txIndex, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, byte, uint64, int32, []byte) error); ok {
		r0 = rf(tokenID, shardID, blockHeight, txIndex, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreOutputCoins provides a mock function with given fields: tokenID, publicKey, outputCoinArr, shardID
func (_m *DatabaseInterface) StoreOutputCoins(tokenID common.Hash, publicKey []byte, outputCoinArr [][]byte, shardID byte) error {
	ret := _m.Called(tokenID, publicKey, outputCoinArr, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, [][]byte, byte) error); ok {
		r0 = rf(tokenID, publicKey, outputCoinArr, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorePrevBestState provides a mock function with given fields: val, isBeacon, shardID
func (_m *DatabaseInterface) StorePrevBestState(val []byte, isBeacon bool, shardID byte) error {
	ret := _m.Called(val, isBeacon, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, bool, byte) error); ok {
		r0 = rf(val, isBeacon, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorePrivacyToken provides a mock function with given fields: tokenID, data
func (_m *DatabaseInterface) StorePrivacyToken(tokenID common.Hash, data []byte) error {
	ret := _m.Called(tokenID, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, []byte) error); ok {
		r0 = rf(tokenID, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorePrivacyTokenCrossShard provides a mock function with given fields: tokenID, tokenValue
func (_m *DatabaseInterface) StorePrivacyTokenCrossShard(tokenID common.Hash, tokenValue []byte) error {
	ret := _m.Called(tokenID, tokenValue)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, []byte) error); ok {
		r0 = rf(tokenID, tokenValue)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorePrivacyTokenTx provides a mock function with given fields: tokenID, shardID, blockHeight, txIndex, txHash
func (_m *DatabaseInterface) StorePrivacyTokenTx(tokenID common.Hash, shardID byte, blockHeight uint64, txIndex int32, txHash []byte) error {
	ret := _m.Called(tokenID, shardID, blockHeight, txIndex, txHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, byte, uint64, int32, []byte) error); ok {
		r0 = rf(tokenID, shardID, blockHeight, txIndex, txHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreRewardReceiverByHeight provides a mock function with given fields: _a0, _a1
func (_m *DatabaseInterface) StoreRewardReceiverByHeight(_a0 uint64, _a1 interface{}) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, interface{}) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreSNDerivators provides a mock function with given fields: tokenID, sndArray, shardID
func (_m *DatabaseInterface) StoreSNDerivators(tokenID common.Hash, sndArray [][]byte, shardID byte) error {
	ret := _m.Called(tokenID, sndArray, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, [][]byte, byte) error); ok {
		r0 = rf(tokenID, sndArray, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreSerialNumbers provides a mock function with given fields: tokenID, serialNumber, shardID
func (_m *DatabaseInterface) StoreSerialNumbers(tokenID common.Hash, serialNumber [][]byte, shardID byte) error {
	ret := _m.Called(tokenID, serialNumber, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, [][]byte, byte) error); ok {
		r0 = rf(tokenID, serialNumber, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreShardBestState provides a mock function with given fields: v, shardID
func (_m *DatabaseInterface) StoreShardBestState(v interface{}, shardID byte) error {
	ret := _m.Called(v, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, byte) error); ok {
		r0 = rf(v, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreShardBlock provides a mock function with given fields: v, hash, shardID
func (_m *DatabaseInterface) StoreShardBlock(v interface{}, hash common.Hash, shardID byte) error {
	ret := _m.Called(v, hash, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, common.Hash, byte) error); ok {
		r0 = rf(v, hash, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreShardBlockIndex provides a mock function with given fields: hash, idx, shardID
func (_m *DatabaseInterface) StoreShardBlockIndex(hash common.Hash, idx uint64, shardID byte) error {
	ret := _m.Called(hash, idx, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, uint64, byte) error); ok {
		r0 = rf(hash, idx, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreShardCommitteeByHeight provides a mock function with given fields: _a0, _a1
func (_m *DatabaseInterface) StoreShardCommitteeByHeight(_a0 uint64, _a1 interface{}) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, interface{}) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreTransactionIndex provides a mock function with given fields: txId, blockHash, indexInBlock
func (_m *DatabaseInterface) StoreTransactionIndex(txId common.Hash, blockHash common.Hash, indexInBlock int) error {
	ret := _m.Called(txId, blockHash, indexInBlock)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, common.Hash, int) error); ok {
		r0 = rf(txId, blockHash, indexInBlock)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreTxByPublicKey provides a mock function with given fields: publicKey, txID, shardID
func (_m *DatabaseInterface) StoreTxByPublicKey(publicKey []byte, txID common.Hash, shardID byte) error {
	ret := _m.Called(publicKey, txID, shardID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, common.Hash, byte) error); ok {
		r0 = rf(publicKey, txID, shardID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TrackBridgeReqWithStatus provides a mock function with given fields: txReqID, status
func (_m *DatabaseInterface) TrackBridgeReqWithStatus(txReqID common.Hash, status byte) error {
	ret := _m.Called(txReqID, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, byte) error); ok {
		r0 = rf(txReqID, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateBridgeTokenInfo provides a mock function with given fields: incTokenID, externalTokenID, isCentralized, updatingAmt, updateType
func (_m *DatabaseInterface) UpdateBridgeTokenInfo(incTokenID common.Hash, externalTokenID []byte, isCentralized bool, updatingAmt uint64, updateType string) error {
	ret := _m.Called(incTokenID, externalTokenID, isCentralized, updatingAmt, updateType)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Hash, []byte, bool, uint64, string) error); ok {
		r0 = rf(incTokenID, externalTokenID, isCentralized, updatingAmt, updateType)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
