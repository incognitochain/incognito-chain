// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zksnark.proto

#ifndef PROTOBUF_zksnark_2eproto__INCLUDED
#define PROTOBUF_zksnark_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_zksnark_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMerkleHashImpl();
void InitDefaultsMerkleHash();
void InitDefaultsMerklePathImpl();
void InitDefaultsMerklePath();
void InitDefaultsNoteImpl();
void InitDefaultsNote();
void InitDefaultsJSInputImpl();
void InitDefaultsJSInput();
void InitDefaultsProveRequestImpl();
void InitDefaultsProveRequest();
void InitDefaultsProveReplyImpl();
void InitDefaultsProveReply();
inline void InitDefaults() {
  InitDefaultsMerkleHash();
  InitDefaultsMerklePath();
  InitDefaultsNote();
  InitDefaultsJSInput();
  InitDefaultsProveRequest();
  InitDefaultsProveReply();
}
}  // namespace protobuf_zksnark_2eproto
namespace zksnark {
class JSInput;
class JSInputDefaultTypeInternal;
extern JSInputDefaultTypeInternal _JSInput_default_instance_;
class MerkleHash;
class MerkleHashDefaultTypeInternal;
extern MerkleHashDefaultTypeInternal _MerkleHash_default_instance_;
class MerklePath;
class MerklePathDefaultTypeInternal;
extern MerklePathDefaultTypeInternal _MerklePath_default_instance_;
class Note;
class NoteDefaultTypeInternal;
extern NoteDefaultTypeInternal _Note_default_instance_;
class ProveReply;
class ProveReplyDefaultTypeInternal;
extern ProveReplyDefaultTypeInternal _ProveReply_default_instance_;
class ProveRequest;
class ProveRequestDefaultTypeInternal;
extern ProveRequestDefaultTypeInternal _ProveRequest_default_instance_;
}  // namespace zksnark
namespace zksnark {

// ===================================================================

class MerkleHash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.MerkleHash) */ {
 public:
  MerkleHash();
  virtual ~MerkleHash();

  MerkleHash(const MerkleHash& from);

  inline MerkleHash& operator=(const MerkleHash& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MerkleHash(MerkleHash&& from) noexcept
    : MerkleHash() {
    *this = ::std::move(from);
  }

  inline MerkleHash& operator=(MerkleHash&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MerkleHash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MerkleHash* internal_default_instance() {
    return reinterpret_cast<const MerkleHash*>(
               &_MerkleHash_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MerkleHash* other);
  friend void swap(MerkleHash& a, MerkleHash& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MerkleHash* New() const PROTOBUF_FINAL { return New(NULL); }

  MerkleHash* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MerkleHash& from);
  void MergeFrom(const MerkleHash& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MerkleHash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:zksnark.MerkleHash)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsMerkleHashImpl();
};
// -------------------------------------------------------------------

class MerklePath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.MerklePath) */ {
 public:
  MerklePath();
  virtual ~MerklePath();

  MerklePath(const MerklePath& from);

  inline MerklePath& operator=(const MerklePath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MerklePath(MerklePath&& from) noexcept
    : MerklePath() {
    *this = ::std::move(from);
  }

  inline MerklePath& operator=(MerklePath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MerklePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MerklePath* internal_default_instance() {
    return reinterpret_cast<const MerklePath*>(
               &_MerklePath_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MerklePath* other);
  friend void swap(MerklePath& a, MerklePath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MerklePath* New() const PROTOBUF_FINAL { return New(NULL); }

  MerklePath* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MerklePath& from);
  void MergeFrom(const MerklePath& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MerklePath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zksnark.MerkleHash authPath = 1;
  int authpath_size() const;
  void clear_authpath();
  static const int kAuthPathFieldNumber = 1;
  const ::zksnark::MerkleHash& authpath(int index) const;
  ::zksnark::MerkleHash* mutable_authpath(int index);
  ::zksnark::MerkleHash* add_authpath();
  ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >*
      mutable_authpath();
  const ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >&
      authpath() const;

  // repeated bool index = 2;
  int index_size() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  bool index(int index) const;
  void set_index(int index, bool value);
  void add_index(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      index() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_index();

  // @@protoc_insertion_point(class_scope:zksnark.MerklePath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash > authpath_;
  ::google::protobuf::RepeatedField< bool > index_;
  mutable int _index_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsMerklePathImpl();
};
// -------------------------------------------------------------------

class Note : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.Note) */ {
 public:
  Note();
  virtual ~Note();

  Note(const Note& from);

  inline Note& operator=(const Note& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Note(Note&& from) noexcept
    : Note() {
    *this = ::std::move(from);
  }

  inline Note& operator=(Note&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Note& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Note* internal_default_instance() {
    return reinterpret_cast<const Note*>(
               &_Note_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Note* other);
  friend void swap(Note& a, Note& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Note* New() const PROTOBUF_FINAL { return New(NULL); }

  Note* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Note& from);
  void MergeFrom(const Note& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Note* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes cm = 2;
  void clear_cm();
  static const int kCmFieldNumber = 2;
  const ::std::string& cm() const;
  void set_cm(const ::std::string& value);
  #if LANG_CXX11
  void set_cm(::std::string&& value);
  #endif
  void set_cm(const char* value);
  void set_cm(const void* value, size_t size);
  ::std::string* mutable_cm();
  ::std::string* release_cm();
  void set_allocated_cm(::std::string* cm);

  // bytes r = 3;
  void clear_r();
  static const int kRFieldNumber = 3;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  #if LANG_CXX11
  void set_r(::std::string&& value);
  #endif
  void set_r(const char* value);
  void set_r(const void* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // bytes rho = 4;
  void clear_rho();
  static const int kRhoFieldNumber = 4;
  const ::std::string& rho() const;
  void set_rho(const ::std::string& value);
  #if LANG_CXX11
  void set_rho(::std::string&& value);
  #endif
  void set_rho(const char* value);
  void set_rho(const void* value, size_t size);
  ::std::string* mutable_rho();
  ::std::string* release_rho();
  void set_allocated_rho(::std::string* rho);

  // bytes apk = 5;
  void clear_apk();
  static const int kApkFieldNumber = 5;
  const ::std::string& apk() const;
  void set_apk(const ::std::string& value);
  #if LANG_CXX11
  void set_apk(::std::string&& value);
  #endif
  void set_apk(const char* value);
  void set_apk(const void* value, size_t size);
  ::std::string* mutable_apk();
  ::std::string* release_apk();
  void set_allocated_apk(::std::string* apk);

  // bytes nf = 6;
  void clear_nf();
  static const int kNfFieldNumber = 6;
  const ::std::string& nf() const;
  void set_nf(const ::std::string& value);
  #if LANG_CXX11
  void set_nf(::std::string&& value);
  #endif
  void set_nf(const char* value);
  void set_nf(const void* value, size_t size);
  ::std::string* mutable_nf();
  ::std::string* release_nf();
  void set_allocated_nf(::std::string* nf);

  // uint64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zksnark.Note)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cm_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  ::google::protobuf::internal::ArenaStringPtr rho_;
  ::google::protobuf::internal::ArenaStringPtr apk_;
  ::google::protobuf::internal::ArenaStringPtr nf_;
  ::google::protobuf::uint64 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsNoteImpl();
};
// -------------------------------------------------------------------

class JSInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.JSInput) */ {
 public:
  JSInput();
  virtual ~JSInput();

  JSInput(const JSInput& from);

  inline JSInput& operator=(const JSInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSInput(JSInput&& from) noexcept
    : JSInput() {
    *this = ::std::move(from);
  }

  inline JSInput& operator=(JSInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSInput* internal_default_instance() {
    return reinterpret_cast<const JSInput*>(
               &_JSInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(JSInput* other);
  friend void swap(JSInput& a, JSInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSInput* New() const PROTOBUF_FINAL { return New(NULL); }

  JSInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JSInput& from);
  void MergeFrom(const JSInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JSInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes spendingKey = 2;
  void clear_spendingkey();
  static const int kSpendingKeyFieldNumber = 2;
  const ::std::string& spendingkey() const;
  void set_spendingkey(const ::std::string& value);
  #if LANG_CXX11
  void set_spendingkey(::std::string&& value);
  #endif
  void set_spendingkey(const char* value);
  void set_spendingkey(const void* value, size_t size);
  ::std::string* mutable_spendingkey();
  ::std::string* release_spendingkey();
  void set_allocated_spendingkey(::std::string* spendingkey);

  // .zksnark.MerklePath witnessPath = 1;
  bool has_witnesspath() const;
  void clear_witnesspath();
  static const int kWitnessPathFieldNumber = 1;
  const ::zksnark::MerklePath& witnesspath() const;
  ::zksnark::MerklePath* release_witnesspath();
  ::zksnark::MerklePath* mutable_witnesspath();
  void set_allocated_witnesspath(::zksnark::MerklePath* witnesspath);

  // .zksnark.Note note = 3;
  bool has_note() const;
  void clear_note();
  static const int kNoteFieldNumber = 3;
  const ::zksnark::Note& note() const;
  ::zksnark::Note* release_note();
  ::zksnark::Note* mutable_note();
  void set_allocated_note(::zksnark::Note* note);

  // @@protoc_insertion_point(class_scope:zksnark.JSInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr spendingkey_;
  ::zksnark::MerklePath* witnesspath_;
  ::zksnark::Note* note_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsJSInputImpl();
};
// -------------------------------------------------------------------

class ProveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.ProveRequest) */ {
 public:
  ProveRequest();
  virtual ~ProveRequest();

  ProveRequest(const ProveRequest& from);

  inline ProveRequest& operator=(const ProveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProveRequest(ProveRequest&& from) noexcept
    : ProveRequest() {
    *this = ::std::move(from);
  }

  inline ProveRequest& operator=(ProveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProveRequest* internal_default_instance() {
    return reinterpret_cast<const ProveRequest*>(
               &_ProveRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ProveRequest* other);
  friend void swap(ProveRequest& a, ProveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProveRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ProveRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProveRequest& from);
  void MergeFrom(const ProveRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zksnark.JSInput inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::zksnark::JSInput& inputs(int index) const;
  ::zksnark::JSInput* mutable_inputs(int index);
  ::zksnark::JSInput* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >&
      inputs() const;

  // repeated .zksnark.Note outNotes = 2;
  int outnotes_size() const;
  void clear_outnotes();
  static const int kOutNotesFieldNumber = 2;
  const ::zksnark::Note& outnotes(int index) const;
  ::zksnark::Note* mutable_outnotes(int index);
  ::zksnark::Note* add_outnotes();
  ::google::protobuf::RepeatedPtrField< ::zksnark::Note >*
      mutable_outnotes();
  const ::google::protobuf::RepeatedPtrField< ::zksnark::Note >&
      outnotes() const;

  // bytes hsig = 3;
  void clear_hsig();
  static const int kHsigFieldNumber = 3;
  const ::std::string& hsig() const;
  void set_hsig(const ::std::string& value);
  #if LANG_CXX11
  void set_hsig(::std::string&& value);
  #endif
  void set_hsig(const char* value);
  void set_hsig(const void* value, size_t size);
  ::std::string* mutable_hsig();
  ::std::string* release_hsig();
  void set_allocated_hsig(::std::string* hsig);

  // bytes phi = 4;
  void clear_phi();
  static const int kPhiFieldNumber = 4;
  const ::std::string& phi() const;
  void set_phi(const ::std::string& value);
  #if LANG_CXX11
  void set_phi(::std::string&& value);
  #endif
  void set_phi(const char* value);
  void set_phi(const void* value, size_t size);
  ::std::string* mutable_phi();
  ::std::string* release_phi();
  void set_allocated_phi(::std::string* phi);

  // bytes rt = 5;
  void clear_rt();
  static const int kRtFieldNumber = 5;
  const ::std::string& rt() const;
  void set_rt(const ::std::string& value);
  #if LANG_CXX11
  void set_rt(::std::string&& value);
  #endif
  void set_rt(const char* value);
  void set_rt(const void* value, size_t size);
  ::std::string* mutable_rt();
  ::std::string* release_rt();
  void set_allocated_rt(::std::string* rt);

  // @@protoc_insertion_point(class_scope:zksnark.ProveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput > inputs_;
  ::google::protobuf::RepeatedPtrField< ::zksnark::Note > outnotes_;
  ::google::protobuf::internal::ArenaStringPtr hsig_;
  ::google::protobuf::internal::ArenaStringPtr phi_;
  ::google::protobuf::internal::ArenaStringPtr rt_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsProveRequestImpl();
};
// -------------------------------------------------------------------

class ProveReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.ProveReply) */ {
 public:
  ProveReply();
  virtual ~ProveReply();

  ProveReply(const ProveReply& from);

  inline ProveReply& operator=(const ProveReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProveReply(ProveReply&& from) noexcept
    : ProveReply() {
    *this = ::std::move(from);
  }

  inline ProveReply& operator=(ProveReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProveReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProveReply* internal_default_instance() {
    return reinterpret_cast<const ProveReply*>(
               &_ProveReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ProveReply* other);
  friend void swap(ProveReply& a, ProveReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProveReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ProveReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProveReply& from);
  void MergeFrom(const ProveReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProveReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dummy = 1;
  void clear_dummy();
  static const int kDummyFieldNumber = 1;
  const ::std::string& dummy() const;
  void set_dummy(const ::std::string& value);
  #if LANG_CXX11
  void set_dummy(::std::string&& value);
  #endif
  void set_dummy(const char* value);
  void set_dummy(const char* value, size_t size);
  ::std::string* mutable_dummy();
  ::std::string* release_dummy();
  void set_allocated_dummy(::std::string* dummy);

  // @@protoc_insertion_point(class_scope:zksnark.ProveReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dummy_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsProveReplyImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MerkleHash

// bytes hash = 1;
inline void MerkleHash::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MerkleHash::hash() const {
  // @@protoc_insertion_point(field_get:zksnark.MerkleHash.hash)
  return hash_.GetNoArena();
}
inline void MerkleHash::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.MerkleHash.hash)
}
#if LANG_CXX11
inline void MerkleHash::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.MerkleHash.hash)
}
#endif
inline void MerkleHash::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.MerkleHash.hash)
}
inline void MerkleHash::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.MerkleHash.hash)
}
inline ::std::string* MerkleHash::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.MerkleHash.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MerkleHash::release_hash() {
  // @@protoc_insertion_point(field_release:zksnark.MerkleHash.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MerkleHash::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:zksnark.MerkleHash.hash)
}

// -------------------------------------------------------------------

// MerklePath

// repeated .zksnark.MerkleHash authPath = 1;
inline int MerklePath::authpath_size() const {
  return authpath_.size();
}
inline void MerklePath::clear_authpath() {
  authpath_.Clear();
}
inline const ::zksnark::MerkleHash& MerklePath::authpath(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.MerklePath.authPath)
  return authpath_.Get(index);
}
inline ::zksnark::MerkleHash* MerklePath::mutable_authpath(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.MerklePath.authPath)
  return authpath_.Mutable(index);
}
inline ::zksnark::MerkleHash* MerklePath::add_authpath() {
  // @@protoc_insertion_point(field_add:zksnark.MerklePath.authPath)
  return authpath_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >*
MerklePath::mutable_authpath() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.MerklePath.authPath)
  return &authpath_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >&
MerklePath::authpath() const {
  // @@protoc_insertion_point(field_list:zksnark.MerklePath.authPath)
  return authpath_;
}

// repeated bool index = 2;
inline int MerklePath::index_size() const {
  return index_.size();
}
inline void MerklePath::clear_index() {
  index_.Clear();
}
inline bool MerklePath::index(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.MerklePath.index)
  return index_.Get(index);
}
inline void MerklePath::set_index(int index, bool value) {
  index_.Set(index, value);
  // @@protoc_insertion_point(field_set:zksnark.MerklePath.index)
}
inline void MerklePath::add_index(bool value) {
  index_.Add(value);
  // @@protoc_insertion_point(field_add:zksnark.MerklePath.index)
}
inline const ::google::protobuf::RepeatedField< bool >&
MerklePath::index() const {
  // @@protoc_insertion_point(field_list:zksnark.MerklePath.index)
  return index_;
}
inline ::google::protobuf::RepeatedField< bool >*
MerklePath::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.MerklePath.index)
  return &index_;
}

// -------------------------------------------------------------------

// Note

// uint64 value = 1;
inline void Note::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Note::value() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.value)
  return value_;
}
inline void Note::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:zksnark.Note.value)
}

// bytes cm = 2;
inline void Note::clear_cm() {
  cm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::cm() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.cm)
  return cm_.GetNoArena();
}
inline void Note::set_cm(const ::std::string& value) {
  
  cm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.cm)
}
#if LANG_CXX11
inline void Note::set_cm(::std::string&& value) {
  
  cm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.cm)
}
#endif
inline void Note::set_cm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.cm)
}
inline void Note::set_cm(const void* value, size_t size) {
  
  cm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.cm)
}
inline ::std::string* Note::mutable_cm() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.cm)
  return cm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_cm() {
  // @@protoc_insertion_point(field_release:zksnark.Note.cm)
  
  return cm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_cm(::std::string* cm) {
  if (cm != NULL) {
    
  } else {
    
  }
  cm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cm);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.cm)
}

// bytes r = 3;
inline void Note::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::r() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.r)
  return r_.GetNoArena();
}
inline void Note::set_r(const ::std::string& value) {
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.r)
}
#if LANG_CXX11
inline void Note::set_r(::std::string&& value) {
  
  r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.r)
}
#endif
inline void Note::set_r(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.r)
}
inline void Note::set_r(const void* value, size_t size) {
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.r)
}
inline ::std::string* Note::mutable_r() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.r)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_r() {
  // @@protoc_insertion_point(field_release:zksnark.Note.r)
  
  return r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_r(::std::string* r) {
  if (r != NULL) {
    
  } else {
    
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.r)
}

// bytes rho = 4;
inline void Note::clear_rho() {
  rho_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::rho() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.rho)
  return rho_.GetNoArena();
}
inline void Note::set_rho(const ::std::string& value) {
  
  rho_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.rho)
}
#if LANG_CXX11
inline void Note::set_rho(::std::string&& value) {
  
  rho_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.rho)
}
#endif
inline void Note::set_rho(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rho_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.rho)
}
inline void Note::set_rho(const void* value, size_t size) {
  
  rho_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.rho)
}
inline ::std::string* Note::mutable_rho() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.rho)
  return rho_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_rho() {
  // @@protoc_insertion_point(field_release:zksnark.Note.rho)
  
  return rho_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_rho(::std::string* rho) {
  if (rho != NULL) {
    
  } else {
    
  }
  rho_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rho);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.rho)
}

// bytes apk = 5;
inline void Note::clear_apk() {
  apk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::apk() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.apk)
  return apk_.GetNoArena();
}
inline void Note::set_apk(const ::std::string& value) {
  
  apk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.apk)
}
#if LANG_CXX11
inline void Note::set_apk(::std::string&& value) {
  
  apk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.apk)
}
#endif
inline void Note::set_apk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  apk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.apk)
}
inline void Note::set_apk(const void* value, size_t size) {
  
  apk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.apk)
}
inline ::std::string* Note::mutable_apk() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.apk)
  return apk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_apk() {
  // @@protoc_insertion_point(field_release:zksnark.Note.apk)
  
  return apk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_apk(::std::string* apk) {
  if (apk != NULL) {
    
  } else {
    
  }
  apk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), apk);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.apk)
}

// bytes nf = 6;
inline void Note::clear_nf() {
  nf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::nf() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.nf)
  return nf_.GetNoArena();
}
inline void Note::set_nf(const ::std::string& value) {
  
  nf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.nf)
}
#if LANG_CXX11
inline void Note::set_nf(::std::string&& value) {
  
  nf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.nf)
}
#endif
inline void Note::set_nf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.nf)
}
inline void Note::set_nf(const void* value, size_t size) {
  
  nf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.nf)
}
inline ::std::string* Note::mutable_nf() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.nf)
  return nf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_nf() {
  // @@protoc_insertion_point(field_release:zksnark.Note.nf)
  
  return nf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_nf(::std::string* nf) {
  if (nf != NULL) {
    
  } else {
    
  }
  nf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nf);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.nf)
}

// -------------------------------------------------------------------

// JSInput

// .zksnark.MerklePath witnessPath = 1;
inline bool JSInput::has_witnesspath() const {
  return this != internal_default_instance() && witnesspath_ != NULL;
}
inline void JSInput::clear_witnesspath() {
  if (GetArenaNoVirtual() == NULL && witnesspath_ != NULL) {
    delete witnesspath_;
  }
  witnesspath_ = NULL;
}
inline const ::zksnark::MerklePath& JSInput::witnesspath() const {
  const ::zksnark::MerklePath* p = witnesspath_;
  // @@protoc_insertion_point(field_get:zksnark.JSInput.witnessPath)
  return p != NULL ? *p : *reinterpret_cast<const ::zksnark::MerklePath*>(
      &::zksnark::_MerklePath_default_instance_);
}
inline ::zksnark::MerklePath* JSInput::release_witnesspath() {
  // @@protoc_insertion_point(field_release:zksnark.JSInput.witnessPath)
  
  ::zksnark::MerklePath* temp = witnesspath_;
  witnesspath_ = NULL;
  return temp;
}
inline ::zksnark::MerklePath* JSInput::mutable_witnesspath() {
  
  if (witnesspath_ == NULL) {
    witnesspath_ = new ::zksnark::MerklePath;
  }
  // @@protoc_insertion_point(field_mutable:zksnark.JSInput.witnessPath)
  return witnesspath_;
}
inline void JSInput::set_allocated_witnesspath(::zksnark::MerklePath* witnesspath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete witnesspath_;
  }
  if (witnesspath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      witnesspath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, witnesspath, submessage_arena);
    }
    
  } else {
    
  }
  witnesspath_ = witnesspath;
  // @@protoc_insertion_point(field_set_allocated:zksnark.JSInput.witnessPath)
}

// bytes spendingKey = 2;
inline void JSInput::clear_spendingkey() {
  spendingkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSInput::spendingkey() const {
  // @@protoc_insertion_point(field_get:zksnark.JSInput.spendingKey)
  return spendingkey_.GetNoArena();
}
inline void JSInput::set_spendingkey(const ::std::string& value) {
  
  spendingkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.JSInput.spendingKey)
}
#if LANG_CXX11
inline void JSInput::set_spendingkey(::std::string&& value) {
  
  spendingkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.JSInput.spendingKey)
}
#endif
inline void JSInput::set_spendingkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  spendingkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.JSInput.spendingKey)
}
inline void JSInput::set_spendingkey(const void* value, size_t size) {
  
  spendingkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.JSInput.spendingKey)
}
inline ::std::string* JSInput::mutable_spendingkey() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.JSInput.spendingKey)
  return spendingkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSInput::release_spendingkey() {
  // @@protoc_insertion_point(field_release:zksnark.JSInput.spendingKey)
  
  return spendingkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSInput::set_allocated_spendingkey(::std::string* spendingkey) {
  if (spendingkey != NULL) {
    
  } else {
    
  }
  spendingkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spendingkey);
  // @@protoc_insertion_point(field_set_allocated:zksnark.JSInput.spendingKey)
}

// .zksnark.Note note = 3;
inline bool JSInput::has_note() const {
  return this != internal_default_instance() && note_ != NULL;
}
inline void JSInput::clear_note() {
  if (GetArenaNoVirtual() == NULL && note_ != NULL) {
    delete note_;
  }
  note_ = NULL;
}
inline const ::zksnark::Note& JSInput::note() const {
  const ::zksnark::Note* p = note_;
  // @@protoc_insertion_point(field_get:zksnark.JSInput.note)
  return p != NULL ? *p : *reinterpret_cast<const ::zksnark::Note*>(
      &::zksnark::_Note_default_instance_);
}
inline ::zksnark::Note* JSInput::release_note() {
  // @@protoc_insertion_point(field_release:zksnark.JSInput.note)
  
  ::zksnark::Note* temp = note_;
  note_ = NULL;
  return temp;
}
inline ::zksnark::Note* JSInput::mutable_note() {
  
  if (note_ == NULL) {
    note_ = new ::zksnark::Note;
  }
  // @@protoc_insertion_point(field_mutable:zksnark.JSInput.note)
  return note_;
}
inline void JSInput::set_allocated_note(::zksnark::Note* note) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete note_;
  }
  if (note) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      note = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:zksnark.JSInput.note)
}

// -------------------------------------------------------------------

// ProveRequest

// repeated .zksnark.JSInput inputs = 1;
inline int ProveRequest::inputs_size() const {
  return inputs_.size();
}
inline void ProveRequest::clear_inputs() {
  inputs_.Clear();
}
inline const ::zksnark::JSInput& ProveRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.inputs)
  return inputs_.Get(index);
}
inline ::zksnark::JSInput* ProveRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.inputs)
  return inputs_.Mutable(index);
}
inline ::zksnark::JSInput* ProveRequest::add_inputs() {
  // @@protoc_insertion_point(field_add:zksnark.ProveRequest.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >*
ProveRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.ProveRequest.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >&
ProveRequest::inputs() const {
  // @@protoc_insertion_point(field_list:zksnark.ProveRequest.inputs)
  return inputs_;
}

// repeated .zksnark.Note outNotes = 2;
inline int ProveRequest::outnotes_size() const {
  return outnotes_.size();
}
inline void ProveRequest::clear_outnotes() {
  outnotes_.Clear();
}
inline const ::zksnark::Note& ProveRequest::outnotes(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.outNotes)
  return outnotes_.Get(index);
}
inline ::zksnark::Note* ProveRequest::mutable_outnotes(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.outNotes)
  return outnotes_.Mutable(index);
}
inline ::zksnark::Note* ProveRequest::add_outnotes() {
  // @@protoc_insertion_point(field_add:zksnark.ProveRequest.outNotes)
  return outnotes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zksnark::Note >*
ProveRequest::mutable_outnotes() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.ProveRequest.outNotes)
  return &outnotes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zksnark::Note >&
ProveRequest::outnotes() const {
  // @@protoc_insertion_point(field_list:zksnark.ProveRequest.outNotes)
  return outnotes_;
}

// bytes hsig = 3;
inline void ProveRequest::clear_hsig() {
  hsig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProveRequest::hsig() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.hsig)
  return hsig_.GetNoArena();
}
inline void ProveRequest::set_hsig(const ::std::string& value) {
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.ProveRequest.hsig)
}
#if LANG_CXX11
inline void ProveRequest::set_hsig(::std::string&& value) {
  
  hsig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.ProveRequest.hsig)
}
#endif
inline void ProveRequest::set_hsig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.ProveRequest.hsig)
}
inline void ProveRequest::set_hsig(const void* value, size_t size) {
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.ProveRequest.hsig)
}
inline ::std::string* ProveRequest::mutable_hsig() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.hsig)
  return hsig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProveRequest::release_hsig() {
  // @@protoc_insertion_point(field_release:zksnark.ProveRequest.hsig)
  
  return hsig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProveRequest::set_allocated_hsig(::std::string* hsig) {
  if (hsig != NULL) {
    
  } else {
    
  }
  hsig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hsig);
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveRequest.hsig)
}

// bytes phi = 4;
inline void ProveRequest::clear_phi() {
  phi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProveRequest::phi() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.phi)
  return phi_.GetNoArena();
}
inline void ProveRequest::set_phi(const ::std::string& value) {
  
  phi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.ProveRequest.phi)
}
#if LANG_CXX11
inline void ProveRequest::set_phi(::std::string&& value) {
  
  phi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.ProveRequest.phi)
}
#endif
inline void ProveRequest::set_phi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  phi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.ProveRequest.phi)
}
inline void ProveRequest::set_phi(const void* value, size_t size) {
  
  phi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.ProveRequest.phi)
}
inline ::std::string* ProveRequest::mutable_phi() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.phi)
  return phi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProveRequest::release_phi() {
  // @@protoc_insertion_point(field_release:zksnark.ProveRequest.phi)
  
  return phi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProveRequest::set_allocated_phi(::std::string* phi) {
  if (phi != NULL) {
    
  } else {
    
  }
  phi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phi);
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveRequest.phi)
}

// bytes rt = 5;
inline void ProveRequest::clear_rt() {
  rt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProveRequest::rt() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.rt)
  return rt_.GetNoArena();
}
inline void ProveRequest::set_rt(const ::std::string& value) {
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.ProveRequest.rt)
}
#if LANG_CXX11
inline void ProveRequest::set_rt(::std::string&& value) {
  
  rt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.ProveRequest.rt)
}
#endif
inline void ProveRequest::set_rt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.ProveRequest.rt)
}
inline void ProveRequest::set_rt(const void* value, size_t size) {
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.ProveRequest.rt)
}
inline ::std::string* ProveRequest::mutable_rt() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.rt)
  return rt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProveRequest::release_rt() {
  // @@protoc_insertion_point(field_release:zksnark.ProveRequest.rt)
  
  return rt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProveRequest::set_allocated_rt(::std::string* rt) {
  if (rt != NULL) {
    
  } else {
    
  }
  rt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rt);
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveRequest.rt)
}

// -------------------------------------------------------------------

// ProveReply

// string dummy = 1;
inline void ProveReply::clear_dummy() {
  dummy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProveReply::dummy() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveReply.dummy)
  return dummy_.GetNoArena();
}
inline void ProveReply::set_dummy(const ::std::string& value) {
  
  dummy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.ProveReply.dummy)
}
#if LANG_CXX11
inline void ProveReply::set_dummy(::std::string&& value) {
  
  dummy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.ProveReply.dummy)
}
#endif
inline void ProveReply::set_dummy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dummy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.ProveReply.dummy)
}
inline void ProveReply::set_dummy(const char* value, size_t size) {
  
  dummy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.ProveReply.dummy)
}
inline ::std::string* ProveReply::mutable_dummy() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.ProveReply.dummy)
  return dummy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProveReply::release_dummy() {
  // @@protoc_insertion_point(field_release:zksnark.ProveReply.dummy)
  
  return dummy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProveReply::set_allocated_dummy(::std::string* dummy) {
  if (dummy != NULL) {
    
  } else {
    
  }
  dummy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dummy);
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveReply.dummy)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zksnark

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_zksnark_2eproto__INCLUDED
