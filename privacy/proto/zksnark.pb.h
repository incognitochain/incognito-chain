// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zksnark.proto

#ifndef PROTOBUF_zksnark_2eproto__INCLUDED
#define PROTOBUF_zksnark_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_zksnark_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMerkleHashImpl();
void InitDefaultsMerkleHash();
void InitDefaultsMerklePathImpl();
void InitDefaultsMerklePath();
void InitDefaultsNoteImpl();
void InitDefaultsNote();
void InitDefaultsJSInputImpl();
void InitDefaultsJSInput();
void InitDefaultsProveRequestImpl();
void InitDefaultsProveRequest();
void InitDefaultsPHGRProofImpl();
void InitDefaultsPHGRProof();
void InitDefaultsProveReplyImpl();
void InitDefaultsProveReply();
void InitDefaultsVerifyRequestImpl();
void InitDefaultsVerifyRequest();
void InitDefaultsVerifyReplyImpl();
void InitDefaultsVerifyReply();
inline void InitDefaults() {
  InitDefaultsMerkleHash();
  InitDefaultsMerklePath();
  InitDefaultsNote();
  InitDefaultsJSInput();
  InitDefaultsProveRequest();
  InitDefaultsPHGRProof();
  InitDefaultsProveReply();
  InitDefaultsVerifyRequest();
  InitDefaultsVerifyReply();
}
}  // namespace protobuf_zksnark_2eproto
namespace zksnark {
class JSInput;
class JSInputDefaultTypeInternal;
extern JSInputDefaultTypeInternal _JSInput_default_instance_;
class MerkleHash;
class MerkleHashDefaultTypeInternal;
extern MerkleHashDefaultTypeInternal _MerkleHash_default_instance_;
class MerklePath;
class MerklePathDefaultTypeInternal;
extern MerklePathDefaultTypeInternal _MerklePath_default_instance_;
class Note;
class NoteDefaultTypeInternal;
extern NoteDefaultTypeInternal _Note_default_instance_;
class PHGRProof;
class PHGRProofDefaultTypeInternal;
extern PHGRProofDefaultTypeInternal _PHGRProof_default_instance_;
class ProveReply;
class ProveReplyDefaultTypeInternal;
extern ProveReplyDefaultTypeInternal _ProveReply_default_instance_;
class ProveRequest;
class ProveRequestDefaultTypeInternal;
extern ProveRequestDefaultTypeInternal _ProveRequest_default_instance_;
class VerifyReply;
class VerifyReplyDefaultTypeInternal;
extern VerifyReplyDefaultTypeInternal _VerifyReply_default_instance_;
class VerifyRequest;
class VerifyRequestDefaultTypeInternal;
extern VerifyRequestDefaultTypeInternal _VerifyRequest_default_instance_;
}  // namespace zksnark
namespace zksnark {

// ===================================================================

class MerkleHash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.MerkleHash) */ {
 public:
  MerkleHash();
  virtual ~MerkleHash();

  MerkleHash(const MerkleHash& from);

  inline MerkleHash& operator=(const MerkleHash& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MerkleHash(MerkleHash&& from) noexcept
    : MerkleHash() {
    *this = ::std::move(from);
  }

  inline MerkleHash& operator=(MerkleHash&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MerkleHash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MerkleHash* internal_default_instance() {
    return reinterpret_cast<const MerkleHash*>(
               &_MerkleHash_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MerkleHash* other);
  friend void swap(MerkleHash& a, MerkleHash& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MerkleHash* New() const PROTOBUF_FINAL { return New(NULL); }

  MerkleHash* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MerkleHash& from);
  void MergeFrom(const MerkleHash& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MerkleHash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:zksnark.MerkleHash)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsMerkleHashImpl();
};
// -------------------------------------------------------------------

class MerklePath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.MerklePath) */ {
 public:
  MerklePath();
  virtual ~MerklePath();

  MerklePath(const MerklePath& from);

  inline MerklePath& operator=(const MerklePath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MerklePath(MerklePath&& from) noexcept
    : MerklePath() {
    *this = ::std::move(from);
  }

  inline MerklePath& operator=(MerklePath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MerklePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MerklePath* internal_default_instance() {
    return reinterpret_cast<const MerklePath*>(
               &_MerklePath_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MerklePath* other);
  friend void swap(MerklePath& a, MerklePath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MerklePath* New() const PROTOBUF_FINAL { return New(NULL); }

  MerklePath* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MerklePath& from);
  void MergeFrom(const MerklePath& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MerklePath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zksnark.MerkleHash authPath = 1;
  int authpath_size() const;
  void clear_authpath();
  static const int kAuthPathFieldNumber = 1;
  const ::zksnark::MerkleHash& authpath(int index) const;
  ::zksnark::MerkleHash* mutable_authpath(int index);
  ::zksnark::MerkleHash* add_authpath();
  ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >*
      mutable_authpath();
  const ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >&
      authpath() const;

  // repeated bool index = 2;
  int index_size() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  bool index(int index) const;
  void set_index(int index, bool value);
  void add_index(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      index() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_index();

  // @@protoc_insertion_point(class_scope:zksnark.MerklePath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash > authpath_;
  ::google::protobuf::RepeatedField< bool > index_;
  mutable int _index_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsMerklePathImpl();
};
// -------------------------------------------------------------------

class Note : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.Note) */ {
 public:
  Note();
  virtual ~Note();

  Note(const Note& from);

  inline Note& operator=(const Note& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Note(Note&& from) noexcept
    : Note() {
    *this = ::std::move(from);
  }

  inline Note& operator=(Note&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Note& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Note* internal_default_instance() {
    return reinterpret_cast<const Note*>(
               &_Note_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Note* other);
  friend void swap(Note& a, Note& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Note* New() const PROTOBUF_FINAL { return New(NULL); }

  Note* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Note& from);
  void MergeFrom(const Note& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Note* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes cm = 2;
  void clear_cm();
  static const int kCmFieldNumber = 2;
  const ::std::string& cm() const;
  void set_cm(const ::std::string& value);
  #if LANG_CXX11
  void set_cm(::std::string&& value);
  #endif
  void set_cm(const char* value);
  void set_cm(const void* value, size_t size);
  ::std::string* mutable_cm();
  ::std::string* release_cm();
  void set_allocated_cm(::std::string* cm);

  // bytes r = 3;
  void clear_r();
  static const int kRFieldNumber = 3;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  #if LANG_CXX11
  void set_r(::std::string&& value);
  #endif
  void set_r(const char* value);
  void set_r(const void* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // bytes rho = 4;
  void clear_rho();
  static const int kRhoFieldNumber = 4;
  const ::std::string& rho() const;
  void set_rho(const ::std::string& value);
  #if LANG_CXX11
  void set_rho(::std::string&& value);
  #endif
  void set_rho(const char* value);
  void set_rho(const void* value, size_t size);
  ::std::string* mutable_rho();
  ::std::string* release_rho();
  void set_allocated_rho(::std::string* rho);

  // bytes apk = 5;
  void clear_apk();
  static const int kApkFieldNumber = 5;
  const ::std::string& apk() const;
  void set_apk(const ::std::string& value);
  #if LANG_CXX11
  void set_apk(::std::string&& value);
  #endif
  void set_apk(const char* value);
  void set_apk(const void* value, size_t size);
  ::std::string* mutable_apk();
  ::std::string* release_apk();
  void set_allocated_apk(::std::string* apk);

  // bytes nf = 6;
  void clear_nf();
  static const int kNfFieldNumber = 6;
  const ::std::string& nf() const;
  void set_nf(const ::std::string& value);
  #if LANG_CXX11
  void set_nf(::std::string&& value);
  #endif
  void set_nf(const char* value);
  void set_nf(const void* value, size_t size);
  ::std::string* mutable_nf();
  ::std::string* release_nf();
  void set_allocated_nf(::std::string* nf);

  // uint64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zksnark.Note)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cm_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  ::google::protobuf::internal::ArenaStringPtr rho_;
  ::google::protobuf::internal::ArenaStringPtr apk_;
  ::google::protobuf::internal::ArenaStringPtr nf_;
  ::google::protobuf::uint64 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsNoteImpl();
};
// -------------------------------------------------------------------

class JSInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.JSInput) */ {
 public:
  JSInput();
  virtual ~JSInput();

  JSInput(const JSInput& from);

  inline JSInput& operator=(const JSInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JSInput(JSInput&& from) noexcept
    : JSInput() {
    *this = ::std::move(from);
  }

  inline JSInput& operator=(JSInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JSInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JSInput* internal_default_instance() {
    return reinterpret_cast<const JSInput*>(
               &_JSInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(JSInput* other);
  friend void swap(JSInput& a, JSInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JSInput* New() const PROTOBUF_FINAL { return New(NULL); }

  JSInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JSInput& from);
  void MergeFrom(const JSInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JSInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes spendingKey = 2;
  void clear_spendingkey();
  static const int kSpendingKeyFieldNumber = 2;
  const ::std::string& spendingkey() const;
  void set_spendingkey(const ::std::string& value);
  #if LANG_CXX11
  void set_spendingkey(::std::string&& value);
  #endif
  void set_spendingkey(const char* value);
  void set_spendingkey(const void* value, size_t size);
  ::std::string* mutable_spendingkey();
  ::std::string* release_spendingkey();
  void set_allocated_spendingkey(::std::string* spendingkey);

  // .zksnark.MerklePath witnessPath = 1;
  bool has_witnesspath() const;
  void clear_witnesspath();
  static const int kWitnessPathFieldNumber = 1;
  const ::zksnark::MerklePath& witnesspath() const;
  ::zksnark::MerklePath* release_witnesspath();
  ::zksnark::MerklePath* mutable_witnesspath();
  void set_allocated_witnesspath(::zksnark::MerklePath* witnesspath);

  // .zksnark.Note note = 3;
  bool has_note() const;
  void clear_note();
  static const int kNoteFieldNumber = 3;
  const ::zksnark::Note& note() const;
  ::zksnark::Note* release_note();
  ::zksnark::Note* mutable_note();
  void set_allocated_note(::zksnark::Note* note);

  // @@protoc_insertion_point(class_scope:zksnark.JSInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr spendingkey_;
  ::zksnark::MerklePath* witnesspath_;
  ::zksnark::Note* note_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsJSInputImpl();
};
// -------------------------------------------------------------------

class ProveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.ProveRequest) */ {
 public:
  ProveRequest();
  virtual ~ProveRequest();

  ProveRequest(const ProveRequest& from);

  inline ProveRequest& operator=(const ProveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProveRequest(ProveRequest&& from) noexcept
    : ProveRequest() {
    *this = ::std::move(from);
  }

  inline ProveRequest& operator=(ProveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProveRequest* internal_default_instance() {
    return reinterpret_cast<const ProveRequest*>(
               &_ProveRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ProveRequest* other);
  friend void swap(ProveRequest& a, ProveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProveRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ProveRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProveRequest& from);
  void MergeFrom(const ProveRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zksnark.JSInput inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::zksnark::JSInput& inputs(int index) const;
  ::zksnark::JSInput* mutable_inputs(int index);
  ::zksnark::JSInput* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >&
      inputs() const;

  // repeated .zksnark.Note outNotes = 2;
  int outnotes_size() const;
  void clear_outnotes();
  static const int kOutNotesFieldNumber = 2;
  const ::zksnark::Note& outnotes(int index) const;
  ::zksnark::Note* mutable_outnotes(int index);
  ::zksnark::Note* add_outnotes();
  ::google::protobuf::RepeatedPtrField< ::zksnark::Note >*
      mutable_outnotes();
  const ::google::protobuf::RepeatedPtrField< ::zksnark::Note >&
      outnotes() const;

  // bytes hsig = 3;
  void clear_hsig();
  static const int kHsigFieldNumber = 3;
  const ::std::string& hsig() const;
  void set_hsig(const ::std::string& value);
  #if LANG_CXX11
  void set_hsig(::std::string&& value);
  #endif
  void set_hsig(const char* value);
  void set_hsig(const void* value, size_t size);
  ::std::string* mutable_hsig();
  ::std::string* release_hsig();
  void set_allocated_hsig(::std::string* hsig);

  // bytes phi = 4;
  void clear_phi();
  static const int kPhiFieldNumber = 4;
  const ::std::string& phi() const;
  void set_phi(const ::std::string& value);
  #if LANG_CXX11
  void set_phi(::std::string&& value);
  #endif
  void set_phi(const char* value);
  void set_phi(const void* value, size_t size);
  ::std::string* mutable_phi();
  ::std::string* release_phi();
  void set_allocated_phi(::std::string* phi);

  // bytes rt = 5;
  void clear_rt();
  static const int kRtFieldNumber = 5;
  const ::std::string& rt() const;
  void set_rt(const ::std::string& value);
  #if LANG_CXX11
  void set_rt(::std::string&& value);
  #endif
  void set_rt(const char* value);
  void set_rt(const void* value, size_t size);
  ::std::string* mutable_rt();
  ::std::string* release_rt();
  void set_allocated_rt(::std::string* rt);

  // uint64 reward = 6;
  void clear_reward();
  static const int kRewardFieldNumber = 6;
  ::google::protobuf::uint64 reward() const;
  void set_reward(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zksnark.ProveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput > inputs_;
  ::google::protobuf::RepeatedPtrField< ::zksnark::Note > outnotes_;
  ::google::protobuf::internal::ArenaStringPtr hsig_;
  ::google::protobuf::internal::ArenaStringPtr phi_;
  ::google::protobuf::internal::ArenaStringPtr rt_;
  ::google::protobuf::uint64 reward_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsProveRequestImpl();
};
// -------------------------------------------------------------------

class PHGRProof : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.PHGRProof) */ {
 public:
  PHGRProof();
  virtual ~PHGRProof();

  PHGRProof(const PHGRProof& from);

  inline PHGRProof& operator=(const PHGRProof& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PHGRProof(PHGRProof&& from) noexcept
    : PHGRProof() {
    *this = ::std::move(from);
  }

  inline PHGRProof& operator=(PHGRProof&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PHGRProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PHGRProof* internal_default_instance() {
    return reinterpret_cast<const PHGRProof*>(
               &_PHGRProof_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PHGRProof* other);
  friend void swap(PHGRProof& a, PHGRProof& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PHGRProof* New() const PROTOBUF_FINAL { return New(NULL); }

  PHGRProof* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PHGRProof& from);
  void MergeFrom(const PHGRProof& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PHGRProof* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes g_A = 1;
  void clear_g_a();
  static const int kGAFieldNumber = 1;
  const ::std::string& g_a() const;
  void set_g_a(const ::std::string& value);
  #if LANG_CXX11
  void set_g_a(::std::string&& value);
  #endif
  void set_g_a(const char* value);
  void set_g_a(const void* value, size_t size);
  ::std::string* mutable_g_a();
  ::std::string* release_g_a();
  void set_allocated_g_a(::std::string* g_a);

  // bytes g_A_prime = 2;
  void clear_g_a_prime();
  static const int kGAPrimeFieldNumber = 2;
  const ::std::string& g_a_prime() const;
  void set_g_a_prime(const ::std::string& value);
  #if LANG_CXX11
  void set_g_a_prime(::std::string&& value);
  #endif
  void set_g_a_prime(const char* value);
  void set_g_a_prime(const void* value, size_t size);
  ::std::string* mutable_g_a_prime();
  ::std::string* release_g_a_prime();
  void set_allocated_g_a_prime(::std::string* g_a_prime);

  // bytes g_B = 3;
  void clear_g_b();
  static const int kGBFieldNumber = 3;
  const ::std::string& g_b() const;
  void set_g_b(const ::std::string& value);
  #if LANG_CXX11
  void set_g_b(::std::string&& value);
  #endif
  void set_g_b(const char* value);
  void set_g_b(const void* value, size_t size);
  ::std::string* mutable_g_b();
  ::std::string* release_g_b();
  void set_allocated_g_b(::std::string* g_b);

  // bytes g_B_prime = 4;
  void clear_g_b_prime();
  static const int kGBPrimeFieldNumber = 4;
  const ::std::string& g_b_prime() const;
  void set_g_b_prime(const ::std::string& value);
  #if LANG_CXX11
  void set_g_b_prime(::std::string&& value);
  #endif
  void set_g_b_prime(const char* value);
  void set_g_b_prime(const void* value, size_t size);
  ::std::string* mutable_g_b_prime();
  ::std::string* release_g_b_prime();
  void set_allocated_g_b_prime(::std::string* g_b_prime);

  // bytes g_C = 5;
  void clear_g_c();
  static const int kGCFieldNumber = 5;
  const ::std::string& g_c() const;
  void set_g_c(const ::std::string& value);
  #if LANG_CXX11
  void set_g_c(::std::string&& value);
  #endif
  void set_g_c(const char* value);
  void set_g_c(const void* value, size_t size);
  ::std::string* mutable_g_c();
  ::std::string* release_g_c();
  void set_allocated_g_c(::std::string* g_c);

  // bytes g_C_prime = 6;
  void clear_g_c_prime();
  static const int kGCPrimeFieldNumber = 6;
  const ::std::string& g_c_prime() const;
  void set_g_c_prime(const ::std::string& value);
  #if LANG_CXX11
  void set_g_c_prime(::std::string&& value);
  #endif
  void set_g_c_prime(const char* value);
  void set_g_c_prime(const void* value, size_t size);
  ::std::string* mutable_g_c_prime();
  ::std::string* release_g_c_prime();
  void set_allocated_g_c_prime(::std::string* g_c_prime);

  // bytes g_K = 7;
  void clear_g_k();
  static const int kGKFieldNumber = 7;
  const ::std::string& g_k() const;
  void set_g_k(const ::std::string& value);
  #if LANG_CXX11
  void set_g_k(::std::string&& value);
  #endif
  void set_g_k(const char* value);
  void set_g_k(const void* value, size_t size);
  ::std::string* mutable_g_k();
  ::std::string* release_g_k();
  void set_allocated_g_k(::std::string* g_k);

  // bytes g_H = 8;
  void clear_g_h();
  static const int kGHFieldNumber = 8;
  const ::std::string& g_h() const;
  void set_g_h(const ::std::string& value);
  #if LANG_CXX11
  void set_g_h(::std::string&& value);
  #endif
  void set_g_h(const char* value);
  void set_g_h(const void* value, size_t size);
  ::std::string* mutable_g_h();
  ::std::string* release_g_h();
  void set_allocated_g_h(::std::string* g_h);

  // @@protoc_insertion_point(class_scope:zksnark.PHGRProof)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr g_a_;
  ::google::protobuf::internal::ArenaStringPtr g_a_prime_;
  ::google::protobuf::internal::ArenaStringPtr g_b_;
  ::google::protobuf::internal::ArenaStringPtr g_b_prime_;
  ::google::protobuf::internal::ArenaStringPtr g_c_;
  ::google::protobuf::internal::ArenaStringPtr g_c_prime_;
  ::google::protobuf::internal::ArenaStringPtr g_k_;
  ::google::protobuf::internal::ArenaStringPtr g_h_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsPHGRProofImpl();
};
// -------------------------------------------------------------------

class ProveReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.ProveReply) */ {
 public:
  ProveReply();
  virtual ~ProveReply();

  ProveReply(const ProveReply& from);

  inline ProveReply& operator=(const ProveReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProveReply(ProveReply&& from) noexcept
    : ProveReply() {
    *this = ::std::move(from);
  }

  inline ProveReply& operator=(ProveReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProveReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProveReply* internal_default_instance() {
    return reinterpret_cast<const ProveReply*>(
               &_ProveReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ProveReply* other);
  friend void swap(ProveReply& a, ProveReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProveReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ProveReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProveReply& from);
  void MergeFrom(const ProveReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProveReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .zksnark.PHGRProof proof = 1;
  bool has_proof() const;
  void clear_proof();
  static const int kProofFieldNumber = 1;
  const ::zksnark::PHGRProof& proof() const;
  ::zksnark::PHGRProof* release_proof();
  ::zksnark::PHGRProof* mutable_proof();
  void set_allocated_proof(::zksnark::PHGRProof* proof);

  // @@protoc_insertion_point(class_scope:zksnark.ProveReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zksnark::PHGRProof* proof_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsProveReplyImpl();
};
// -------------------------------------------------------------------

class VerifyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.VerifyRequest) */ {
 public:
  VerifyRequest();
  virtual ~VerifyRequest();

  VerifyRequest(const VerifyRequest& from);

  inline VerifyRequest& operator=(const VerifyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VerifyRequest(VerifyRequest&& from) noexcept
    : VerifyRequest() {
    *this = ::std::move(from);
  }

  inline VerifyRequest& operator=(VerifyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifyRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyRequest*>(
               &_VerifyRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(VerifyRequest* other);
  friend void swap(VerifyRequest& a, VerifyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VerifyRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyRequest& from);
  void MergeFrom(const VerifyRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes nullifiers = 4;
  int nullifiers_size() const;
  void clear_nullifiers();
  static const int kNullifiersFieldNumber = 4;
  const ::std::string& nullifiers(int index) const;
  ::std::string* mutable_nullifiers(int index);
  void set_nullifiers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_nullifiers(int index, ::std::string&& value);
  #endif
  void set_nullifiers(int index, const char* value);
  void set_nullifiers(int index, const void* value, size_t size);
  ::std::string* add_nullifiers();
  void add_nullifiers(const ::std::string& value);
  #if LANG_CXX11
  void add_nullifiers(::std::string&& value);
  #endif
  void add_nullifiers(const char* value);
  void add_nullifiers(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& nullifiers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nullifiers();

  // repeated bytes commits = 5;
  int commits_size() const;
  void clear_commits();
  static const int kCommitsFieldNumber = 5;
  const ::std::string& commits(int index) const;
  ::std::string* mutable_commits(int index);
  void set_commits(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_commits(int index, ::std::string&& value);
  #endif
  void set_commits(int index, const char* value);
  void set_commits(int index, const void* value, size_t size);
  ::std::string* add_commits();
  void add_commits(const ::std::string& value);
  #if LANG_CXX11
  void add_commits(::std::string&& value);
  #endif
  void add_commits(const char* value);
  void add_commits(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& commits() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_commits();

  // bytes hsig = 2;
  void clear_hsig();
  static const int kHsigFieldNumber = 2;
  const ::std::string& hsig() const;
  void set_hsig(const ::std::string& value);
  #if LANG_CXX11
  void set_hsig(::std::string&& value);
  #endif
  void set_hsig(const char* value);
  void set_hsig(const void* value, size_t size);
  ::std::string* mutable_hsig();
  ::std::string* release_hsig();
  void set_allocated_hsig(::std::string* hsig);

  // bytes rt = 3;
  void clear_rt();
  static const int kRtFieldNumber = 3;
  const ::std::string& rt() const;
  void set_rt(const ::std::string& value);
  #if LANG_CXX11
  void set_rt(::std::string&& value);
  #endif
  void set_rt(const char* value);
  void set_rt(const void* value, size_t size);
  ::std::string* mutable_rt();
  ::std::string* release_rt();
  void set_allocated_rt(::std::string* rt);

  // .zksnark.PHGRProof proof = 1;
  bool has_proof() const;
  void clear_proof();
  static const int kProofFieldNumber = 1;
  const ::zksnark::PHGRProof& proof() const;
  ::zksnark::PHGRProof* release_proof();
  ::zksnark::PHGRProof* mutable_proof();
  void set_allocated_proof(::zksnark::PHGRProof* proof);

  // uint64 reward = 6;
  void clear_reward();
  static const int kRewardFieldNumber = 6;
  ::google::protobuf::uint64 reward() const;
  void set_reward(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zksnark.VerifyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nullifiers_;
  ::google::protobuf::RepeatedPtrField< ::std::string> commits_;
  ::google::protobuf::internal::ArenaStringPtr hsig_;
  ::google::protobuf::internal::ArenaStringPtr rt_;
  ::zksnark::PHGRProof* proof_;
  ::google::protobuf::uint64 reward_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsVerifyRequestImpl();
};
// -------------------------------------------------------------------

class VerifyReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zksnark.VerifyReply) */ {
 public:
  VerifyReply();
  virtual ~VerifyReply();

  VerifyReply(const VerifyReply& from);

  inline VerifyReply& operator=(const VerifyReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VerifyReply(VerifyReply&& from) noexcept
    : VerifyReply() {
    *this = ::std::move(from);
  }

  inline VerifyReply& operator=(VerifyReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifyReply* internal_default_instance() {
    return reinterpret_cast<const VerifyReply*>(
               &_VerifyReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(VerifyReply* other);
  friend void swap(VerifyReply& a, VerifyReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VerifyReply* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyReply& from);
  void MergeFrom(const VerifyReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool valid = 1;
  void clear_valid();
  static const int kValidFieldNumber = 1;
  bool valid() const;
  void set_valid(bool value);

  // @@protoc_insertion_point(class_scope:zksnark.VerifyReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool valid_;
  mutable int _cached_size_;
  friend struct ::protobuf_zksnark_2eproto::TableStruct;
  friend void ::protobuf_zksnark_2eproto::InitDefaultsVerifyReplyImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MerkleHash

// bytes hash = 1;
inline void MerkleHash::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MerkleHash::hash() const {
  // @@protoc_insertion_point(field_get:zksnark.MerkleHash.hash)
  return hash_.GetNoArena();
}
inline void MerkleHash::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.MerkleHash.hash)
}
#if LANG_CXX11
inline void MerkleHash::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.MerkleHash.hash)
}
#endif
inline void MerkleHash::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.MerkleHash.hash)
}
inline void MerkleHash::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.MerkleHash.hash)
}
inline ::std::string* MerkleHash::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.MerkleHash.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MerkleHash::release_hash() {
  // @@protoc_insertion_point(field_release:zksnark.MerkleHash.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MerkleHash::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:zksnark.MerkleHash.hash)
}

// -------------------------------------------------------------------

// MerklePath

// repeated .zksnark.MerkleHash authPath = 1;
inline int MerklePath::authpath_size() const {
  return authpath_.size();
}
inline void MerklePath::clear_authpath() {
  authpath_.Clear();
}
inline const ::zksnark::MerkleHash& MerklePath::authpath(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.MerklePath.authPath)
  return authpath_.Get(index);
}
inline ::zksnark::MerkleHash* MerklePath::mutable_authpath(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.MerklePath.authPath)
  return authpath_.Mutable(index);
}
inline ::zksnark::MerkleHash* MerklePath::add_authpath() {
  // @@protoc_insertion_point(field_add:zksnark.MerklePath.authPath)
  return authpath_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >*
MerklePath::mutable_authpath() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.MerklePath.authPath)
  return &authpath_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zksnark::MerkleHash >&
MerklePath::authpath() const {
  // @@protoc_insertion_point(field_list:zksnark.MerklePath.authPath)
  return authpath_;
}

// repeated bool index = 2;
inline int MerklePath::index_size() const {
  return index_.size();
}
inline void MerklePath::clear_index() {
  index_.Clear();
}
inline bool MerklePath::index(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.MerklePath.index)
  return index_.Get(index);
}
inline void MerklePath::set_index(int index, bool value) {
  index_.Set(index, value);
  // @@protoc_insertion_point(field_set:zksnark.MerklePath.index)
}
inline void MerklePath::add_index(bool value) {
  index_.Add(value);
  // @@protoc_insertion_point(field_add:zksnark.MerklePath.index)
}
inline const ::google::protobuf::RepeatedField< bool >&
MerklePath::index() const {
  // @@protoc_insertion_point(field_list:zksnark.MerklePath.index)
  return index_;
}
inline ::google::protobuf::RepeatedField< bool >*
MerklePath::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.MerklePath.index)
  return &index_;
}

// -------------------------------------------------------------------

// Note

// uint64 value = 1;
inline void Note::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Note::value() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.value)
  return value_;
}
inline void Note::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:zksnark.Note.value)
}

// bytes cm = 2;
inline void Note::clear_cm() {
  cm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::cm() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.cm)
  return cm_.GetNoArena();
}
inline void Note::set_cm(const ::std::string& value) {
  
  cm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.cm)
}
#if LANG_CXX11
inline void Note::set_cm(::std::string&& value) {
  
  cm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.cm)
}
#endif
inline void Note::set_cm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.cm)
}
inline void Note::set_cm(const void* value, size_t size) {
  
  cm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.cm)
}
inline ::std::string* Note::mutable_cm() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.cm)
  return cm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_cm() {
  // @@protoc_insertion_point(field_release:zksnark.Note.cm)
  
  return cm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_cm(::std::string* cm) {
  if (cm != NULL) {
    
  } else {
    
  }
  cm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cm);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.cm)
}

// bytes r = 3;
inline void Note::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::r() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.r)
  return r_.GetNoArena();
}
inline void Note::set_r(const ::std::string& value) {
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.r)
}
#if LANG_CXX11
inline void Note::set_r(::std::string&& value) {
  
  r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.r)
}
#endif
inline void Note::set_r(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.r)
}
inline void Note::set_r(const void* value, size_t size) {
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.r)
}
inline ::std::string* Note::mutable_r() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.r)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_r() {
  // @@protoc_insertion_point(field_release:zksnark.Note.r)
  
  return r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_r(::std::string* r) {
  if (r != NULL) {
    
  } else {
    
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.r)
}

// bytes rho = 4;
inline void Note::clear_rho() {
  rho_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::rho() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.rho)
  return rho_.GetNoArena();
}
inline void Note::set_rho(const ::std::string& value) {
  
  rho_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.rho)
}
#if LANG_CXX11
inline void Note::set_rho(::std::string&& value) {
  
  rho_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.rho)
}
#endif
inline void Note::set_rho(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rho_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.rho)
}
inline void Note::set_rho(const void* value, size_t size) {
  
  rho_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.rho)
}
inline ::std::string* Note::mutable_rho() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.rho)
  return rho_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_rho() {
  // @@protoc_insertion_point(field_release:zksnark.Note.rho)
  
  return rho_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_rho(::std::string* rho) {
  if (rho != NULL) {
    
  } else {
    
  }
  rho_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rho);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.rho)
}

// bytes apk = 5;
inline void Note::clear_apk() {
  apk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::apk() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.apk)
  return apk_.GetNoArena();
}
inline void Note::set_apk(const ::std::string& value) {
  
  apk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.apk)
}
#if LANG_CXX11
inline void Note::set_apk(::std::string&& value) {
  
  apk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.apk)
}
#endif
inline void Note::set_apk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  apk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.apk)
}
inline void Note::set_apk(const void* value, size_t size) {
  
  apk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.apk)
}
inline ::std::string* Note::mutable_apk() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.apk)
  return apk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_apk() {
  // @@protoc_insertion_point(field_release:zksnark.Note.apk)
  
  return apk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_apk(::std::string* apk) {
  if (apk != NULL) {
    
  } else {
    
  }
  apk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), apk);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.apk)
}

// bytes nf = 6;
inline void Note::clear_nf() {
  nf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Note::nf() const {
  // @@protoc_insertion_point(field_get:zksnark.Note.nf)
  return nf_.GetNoArena();
}
inline void Note::set_nf(const ::std::string& value) {
  
  nf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.Note.nf)
}
#if LANG_CXX11
inline void Note::set_nf(::std::string&& value) {
  
  nf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.Note.nf)
}
#endif
inline void Note::set_nf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.Note.nf)
}
inline void Note::set_nf(const void* value, size_t size) {
  
  nf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.Note.nf)
}
inline ::std::string* Note::mutable_nf() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.Note.nf)
  return nf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Note::release_nf() {
  // @@protoc_insertion_point(field_release:zksnark.Note.nf)
  
  return nf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Note::set_allocated_nf(::std::string* nf) {
  if (nf != NULL) {
    
  } else {
    
  }
  nf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nf);
  // @@protoc_insertion_point(field_set_allocated:zksnark.Note.nf)
}

// -------------------------------------------------------------------

// JSInput

// .zksnark.MerklePath witnessPath = 1;
inline bool JSInput::has_witnesspath() const {
  return this != internal_default_instance() && witnesspath_ != NULL;
}
inline void JSInput::clear_witnesspath() {
  if (GetArenaNoVirtual() == NULL && witnesspath_ != NULL) {
    delete witnesspath_;
  }
  witnesspath_ = NULL;
}
inline const ::zksnark::MerklePath& JSInput::witnesspath() const {
  const ::zksnark::MerklePath* p = witnesspath_;
  // @@protoc_insertion_point(field_get:zksnark.JSInput.witnessPath)
  return p != NULL ? *p : *reinterpret_cast<const ::zksnark::MerklePath*>(
      &::zksnark::_MerklePath_default_instance_);
}
inline ::zksnark::MerklePath* JSInput::release_witnesspath() {
  // @@protoc_insertion_point(field_release:zksnark.JSInput.witnessPath)
  
  ::zksnark::MerklePath* temp = witnesspath_;
  witnesspath_ = NULL;
  return temp;
}
inline ::zksnark::MerklePath* JSInput::mutable_witnesspath() {
  
  if (witnesspath_ == NULL) {
    witnesspath_ = new ::zksnark::MerklePath;
  }
  // @@protoc_insertion_point(field_mutable:zksnark.JSInput.witnessPath)
  return witnesspath_;
}
inline void JSInput::set_allocated_witnesspath(::zksnark::MerklePath* witnesspath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete witnesspath_;
  }
  if (witnesspath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      witnesspath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, witnesspath, submessage_arena);
    }
    
  } else {
    
  }
  witnesspath_ = witnesspath;
  // @@protoc_insertion_point(field_set_allocated:zksnark.JSInput.witnessPath)
}

// bytes spendingKey = 2;
inline void JSInput::clear_spendingkey() {
  spendingkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JSInput::spendingkey() const {
  // @@protoc_insertion_point(field_get:zksnark.JSInput.spendingKey)
  return spendingkey_.GetNoArena();
}
inline void JSInput::set_spendingkey(const ::std::string& value) {
  
  spendingkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.JSInput.spendingKey)
}
#if LANG_CXX11
inline void JSInput::set_spendingkey(::std::string&& value) {
  
  spendingkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.JSInput.spendingKey)
}
#endif
inline void JSInput::set_spendingkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  spendingkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.JSInput.spendingKey)
}
inline void JSInput::set_spendingkey(const void* value, size_t size) {
  
  spendingkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.JSInput.spendingKey)
}
inline ::std::string* JSInput::mutable_spendingkey() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.JSInput.spendingKey)
  return spendingkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JSInput::release_spendingkey() {
  // @@protoc_insertion_point(field_release:zksnark.JSInput.spendingKey)
  
  return spendingkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JSInput::set_allocated_spendingkey(::std::string* spendingkey) {
  if (spendingkey != NULL) {
    
  } else {
    
  }
  spendingkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spendingkey);
  // @@protoc_insertion_point(field_set_allocated:zksnark.JSInput.spendingKey)
}

// .zksnark.Note note = 3;
inline bool JSInput::has_note() const {
  return this != internal_default_instance() && note_ != NULL;
}
inline void JSInput::clear_note() {
  if (GetArenaNoVirtual() == NULL && note_ != NULL) {
    delete note_;
  }
  note_ = NULL;
}
inline const ::zksnark::Note& JSInput::note() const {
  const ::zksnark::Note* p = note_;
  // @@protoc_insertion_point(field_get:zksnark.JSInput.note)
  return p != NULL ? *p : *reinterpret_cast<const ::zksnark::Note*>(
      &::zksnark::_Note_default_instance_);
}
inline ::zksnark::Note* JSInput::release_note() {
  // @@protoc_insertion_point(field_release:zksnark.JSInput.note)
  
  ::zksnark::Note* temp = note_;
  note_ = NULL;
  return temp;
}
inline ::zksnark::Note* JSInput::mutable_note() {
  
  if (note_ == NULL) {
    note_ = new ::zksnark::Note;
  }
  // @@protoc_insertion_point(field_mutable:zksnark.JSInput.note)
  return note_;
}
inline void JSInput::set_allocated_note(::zksnark::Note* note) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete note_;
  }
  if (note) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      note = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:zksnark.JSInput.note)
}

// -------------------------------------------------------------------

// ProveRequest

// repeated .zksnark.JSInput inputs = 1;
inline int ProveRequest::inputs_size() const {
  return inputs_.size();
}
inline void ProveRequest::clear_inputs() {
  inputs_.Clear();
}
inline const ::zksnark::JSInput& ProveRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.inputs)
  return inputs_.Get(index);
}
inline ::zksnark::JSInput* ProveRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.inputs)
  return inputs_.Mutable(index);
}
inline ::zksnark::JSInput* ProveRequest::add_inputs() {
  // @@protoc_insertion_point(field_add:zksnark.ProveRequest.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >*
ProveRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.ProveRequest.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zksnark::JSInput >&
ProveRequest::inputs() const {
  // @@protoc_insertion_point(field_list:zksnark.ProveRequest.inputs)
  return inputs_;
}

// repeated .zksnark.Note outNotes = 2;
inline int ProveRequest::outnotes_size() const {
  return outnotes_.size();
}
inline void ProveRequest::clear_outnotes() {
  outnotes_.Clear();
}
inline const ::zksnark::Note& ProveRequest::outnotes(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.outNotes)
  return outnotes_.Get(index);
}
inline ::zksnark::Note* ProveRequest::mutable_outnotes(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.outNotes)
  return outnotes_.Mutable(index);
}
inline ::zksnark::Note* ProveRequest::add_outnotes() {
  // @@protoc_insertion_point(field_add:zksnark.ProveRequest.outNotes)
  return outnotes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zksnark::Note >*
ProveRequest::mutable_outnotes() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.ProveRequest.outNotes)
  return &outnotes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zksnark::Note >&
ProveRequest::outnotes() const {
  // @@protoc_insertion_point(field_list:zksnark.ProveRequest.outNotes)
  return outnotes_;
}

// bytes hsig = 3;
inline void ProveRequest::clear_hsig() {
  hsig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProveRequest::hsig() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.hsig)
  return hsig_.GetNoArena();
}
inline void ProveRequest::set_hsig(const ::std::string& value) {
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.ProveRequest.hsig)
}
#if LANG_CXX11
inline void ProveRequest::set_hsig(::std::string&& value) {
  
  hsig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.ProveRequest.hsig)
}
#endif
inline void ProveRequest::set_hsig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.ProveRequest.hsig)
}
inline void ProveRequest::set_hsig(const void* value, size_t size) {
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.ProveRequest.hsig)
}
inline ::std::string* ProveRequest::mutable_hsig() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.hsig)
  return hsig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProveRequest::release_hsig() {
  // @@protoc_insertion_point(field_release:zksnark.ProveRequest.hsig)
  
  return hsig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProveRequest::set_allocated_hsig(::std::string* hsig) {
  if (hsig != NULL) {
    
  } else {
    
  }
  hsig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hsig);
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveRequest.hsig)
}

// bytes phi = 4;
inline void ProveRequest::clear_phi() {
  phi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProveRequest::phi() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.phi)
  return phi_.GetNoArena();
}
inline void ProveRequest::set_phi(const ::std::string& value) {
  
  phi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.ProveRequest.phi)
}
#if LANG_CXX11
inline void ProveRequest::set_phi(::std::string&& value) {
  
  phi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.ProveRequest.phi)
}
#endif
inline void ProveRequest::set_phi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  phi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.ProveRequest.phi)
}
inline void ProveRequest::set_phi(const void* value, size_t size) {
  
  phi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.ProveRequest.phi)
}
inline ::std::string* ProveRequest::mutable_phi() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.phi)
  return phi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProveRequest::release_phi() {
  // @@protoc_insertion_point(field_release:zksnark.ProveRequest.phi)
  
  return phi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProveRequest::set_allocated_phi(::std::string* phi) {
  if (phi != NULL) {
    
  } else {
    
  }
  phi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phi);
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveRequest.phi)
}

// bytes rt = 5;
inline void ProveRequest::clear_rt() {
  rt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProveRequest::rt() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.rt)
  return rt_.GetNoArena();
}
inline void ProveRequest::set_rt(const ::std::string& value) {
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.ProveRequest.rt)
}
#if LANG_CXX11
inline void ProveRequest::set_rt(::std::string&& value) {
  
  rt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.ProveRequest.rt)
}
#endif
inline void ProveRequest::set_rt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.ProveRequest.rt)
}
inline void ProveRequest::set_rt(const void* value, size_t size) {
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.ProveRequest.rt)
}
inline ::std::string* ProveRequest::mutable_rt() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.ProveRequest.rt)
  return rt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProveRequest::release_rt() {
  // @@protoc_insertion_point(field_release:zksnark.ProveRequest.rt)
  
  return rt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProveRequest::set_allocated_rt(::std::string* rt) {
  if (rt != NULL) {
    
  } else {
    
  }
  rt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rt);
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveRequest.rt)
}

// uint64 reward = 6;
inline void ProveRequest::clear_reward() {
  reward_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ProveRequest::reward() const {
  // @@protoc_insertion_point(field_get:zksnark.ProveRequest.reward)
  return reward_;
}
inline void ProveRequest::set_reward(::google::protobuf::uint64 value) {
  
  reward_ = value;
  // @@protoc_insertion_point(field_set:zksnark.ProveRequest.reward)
}

// -------------------------------------------------------------------

// PHGRProof

// bytes g_A = 1;
inline void PHGRProof::clear_g_a() {
  g_a_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_a() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_A)
  return g_a_.GetNoArena();
}
inline void PHGRProof::set_g_a(const ::std::string& value) {
  
  g_a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_A)
}
#if LANG_CXX11
inline void PHGRProof::set_g_a(::std::string&& value) {
  
  g_a_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_A)
}
#endif
inline void PHGRProof::set_g_a(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_A)
}
inline void PHGRProof::set_g_a(const void* value, size_t size) {
  
  g_a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_A)
}
inline ::std::string* PHGRProof::mutable_g_a() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_A)
  return g_a_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_a() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_A)
  
  return g_a_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_a(::std::string* g_a) {
  if (g_a != NULL) {
    
  } else {
    
  }
  g_a_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_a);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_A)
}

// bytes g_A_prime = 2;
inline void PHGRProof::clear_g_a_prime() {
  g_a_prime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_a_prime() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_A_prime)
  return g_a_prime_.GetNoArena();
}
inline void PHGRProof::set_g_a_prime(const ::std::string& value) {
  
  g_a_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_A_prime)
}
#if LANG_CXX11
inline void PHGRProof::set_g_a_prime(::std::string&& value) {
  
  g_a_prime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_A_prime)
}
#endif
inline void PHGRProof::set_g_a_prime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_a_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_A_prime)
}
inline void PHGRProof::set_g_a_prime(const void* value, size_t size) {
  
  g_a_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_A_prime)
}
inline ::std::string* PHGRProof::mutable_g_a_prime() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_A_prime)
  return g_a_prime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_a_prime() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_A_prime)
  
  return g_a_prime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_a_prime(::std::string* g_a_prime) {
  if (g_a_prime != NULL) {
    
  } else {
    
  }
  g_a_prime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_a_prime);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_A_prime)
}

// bytes g_B = 3;
inline void PHGRProof::clear_g_b() {
  g_b_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_b() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_B)
  return g_b_.GetNoArena();
}
inline void PHGRProof::set_g_b(const ::std::string& value) {
  
  g_b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_B)
}
#if LANG_CXX11
inline void PHGRProof::set_g_b(::std::string&& value) {
  
  g_b_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_B)
}
#endif
inline void PHGRProof::set_g_b(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_B)
}
inline void PHGRProof::set_g_b(const void* value, size_t size) {
  
  g_b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_B)
}
inline ::std::string* PHGRProof::mutable_g_b() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_B)
  return g_b_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_b() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_B)
  
  return g_b_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_b(::std::string* g_b) {
  if (g_b != NULL) {
    
  } else {
    
  }
  g_b_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_b);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_B)
}

// bytes g_B_prime = 4;
inline void PHGRProof::clear_g_b_prime() {
  g_b_prime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_b_prime() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_B_prime)
  return g_b_prime_.GetNoArena();
}
inline void PHGRProof::set_g_b_prime(const ::std::string& value) {
  
  g_b_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_B_prime)
}
#if LANG_CXX11
inline void PHGRProof::set_g_b_prime(::std::string&& value) {
  
  g_b_prime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_B_prime)
}
#endif
inline void PHGRProof::set_g_b_prime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_b_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_B_prime)
}
inline void PHGRProof::set_g_b_prime(const void* value, size_t size) {
  
  g_b_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_B_prime)
}
inline ::std::string* PHGRProof::mutable_g_b_prime() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_B_prime)
  return g_b_prime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_b_prime() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_B_prime)
  
  return g_b_prime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_b_prime(::std::string* g_b_prime) {
  if (g_b_prime != NULL) {
    
  } else {
    
  }
  g_b_prime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_b_prime);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_B_prime)
}

// bytes g_C = 5;
inline void PHGRProof::clear_g_c() {
  g_c_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_c() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_C)
  return g_c_.GetNoArena();
}
inline void PHGRProof::set_g_c(const ::std::string& value) {
  
  g_c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_C)
}
#if LANG_CXX11
inline void PHGRProof::set_g_c(::std::string&& value) {
  
  g_c_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_C)
}
#endif
inline void PHGRProof::set_g_c(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_C)
}
inline void PHGRProof::set_g_c(const void* value, size_t size) {
  
  g_c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_C)
}
inline ::std::string* PHGRProof::mutable_g_c() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_C)
  return g_c_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_c() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_C)
  
  return g_c_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_c(::std::string* g_c) {
  if (g_c != NULL) {
    
  } else {
    
  }
  g_c_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_c);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_C)
}

// bytes g_C_prime = 6;
inline void PHGRProof::clear_g_c_prime() {
  g_c_prime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_c_prime() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_C_prime)
  return g_c_prime_.GetNoArena();
}
inline void PHGRProof::set_g_c_prime(const ::std::string& value) {
  
  g_c_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_C_prime)
}
#if LANG_CXX11
inline void PHGRProof::set_g_c_prime(::std::string&& value) {
  
  g_c_prime_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_C_prime)
}
#endif
inline void PHGRProof::set_g_c_prime(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_c_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_C_prime)
}
inline void PHGRProof::set_g_c_prime(const void* value, size_t size) {
  
  g_c_prime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_C_prime)
}
inline ::std::string* PHGRProof::mutable_g_c_prime() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_C_prime)
  return g_c_prime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_c_prime() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_C_prime)
  
  return g_c_prime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_c_prime(::std::string* g_c_prime) {
  if (g_c_prime != NULL) {
    
  } else {
    
  }
  g_c_prime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_c_prime);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_C_prime)
}

// bytes g_K = 7;
inline void PHGRProof::clear_g_k() {
  g_k_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_k() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_K)
  return g_k_.GetNoArena();
}
inline void PHGRProof::set_g_k(const ::std::string& value) {
  
  g_k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_K)
}
#if LANG_CXX11
inline void PHGRProof::set_g_k(::std::string&& value) {
  
  g_k_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_K)
}
#endif
inline void PHGRProof::set_g_k(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_K)
}
inline void PHGRProof::set_g_k(const void* value, size_t size) {
  
  g_k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_K)
}
inline ::std::string* PHGRProof::mutable_g_k() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_K)
  return g_k_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_k() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_K)
  
  return g_k_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_k(::std::string* g_k) {
  if (g_k != NULL) {
    
  } else {
    
  }
  g_k_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_k);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_K)
}

// bytes g_H = 8;
inline void PHGRProof::clear_g_h() {
  g_h_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PHGRProof::g_h() const {
  // @@protoc_insertion_point(field_get:zksnark.PHGRProof.g_H)
  return g_h_.GetNoArena();
}
inline void PHGRProof::set_g_h(const ::std::string& value) {
  
  g_h_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.PHGRProof.g_H)
}
#if LANG_CXX11
inline void PHGRProof::set_g_h(::std::string&& value) {
  
  g_h_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.PHGRProof.g_H)
}
#endif
inline void PHGRProof::set_g_h(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  g_h_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.PHGRProof.g_H)
}
inline void PHGRProof::set_g_h(const void* value, size_t size) {
  
  g_h_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.PHGRProof.g_H)
}
inline ::std::string* PHGRProof::mutable_g_h() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.PHGRProof.g_H)
  return g_h_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PHGRProof::release_g_h() {
  // @@protoc_insertion_point(field_release:zksnark.PHGRProof.g_H)
  
  return g_h_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PHGRProof::set_allocated_g_h(::std::string* g_h) {
  if (g_h != NULL) {
    
  } else {
    
  }
  g_h_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g_h);
  // @@protoc_insertion_point(field_set_allocated:zksnark.PHGRProof.g_H)
}

// -------------------------------------------------------------------

// ProveReply

// .zksnark.PHGRProof proof = 1;
inline bool ProveReply::has_proof() const {
  return this != internal_default_instance() && proof_ != NULL;
}
inline void ProveReply::clear_proof() {
  if (GetArenaNoVirtual() == NULL && proof_ != NULL) {
    delete proof_;
  }
  proof_ = NULL;
}
inline const ::zksnark::PHGRProof& ProveReply::proof() const {
  const ::zksnark::PHGRProof* p = proof_;
  // @@protoc_insertion_point(field_get:zksnark.ProveReply.proof)
  return p != NULL ? *p : *reinterpret_cast<const ::zksnark::PHGRProof*>(
      &::zksnark::_PHGRProof_default_instance_);
}
inline ::zksnark::PHGRProof* ProveReply::release_proof() {
  // @@protoc_insertion_point(field_release:zksnark.ProveReply.proof)
  
  ::zksnark::PHGRProof* temp = proof_;
  proof_ = NULL;
  return temp;
}
inline ::zksnark::PHGRProof* ProveReply::mutable_proof() {
  
  if (proof_ == NULL) {
    proof_ = new ::zksnark::PHGRProof;
  }
  // @@protoc_insertion_point(field_mutable:zksnark.ProveReply.proof)
  return proof_;
}
inline void ProveReply::set_allocated_proof(::zksnark::PHGRProof* proof) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete proof_;
  }
  if (proof) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      proof = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proof, submessage_arena);
    }
    
  } else {
    
  }
  proof_ = proof;
  // @@protoc_insertion_point(field_set_allocated:zksnark.ProveReply.proof)
}

// -------------------------------------------------------------------

// VerifyRequest

// .zksnark.PHGRProof proof = 1;
inline bool VerifyRequest::has_proof() const {
  return this != internal_default_instance() && proof_ != NULL;
}
inline void VerifyRequest::clear_proof() {
  if (GetArenaNoVirtual() == NULL && proof_ != NULL) {
    delete proof_;
  }
  proof_ = NULL;
}
inline const ::zksnark::PHGRProof& VerifyRequest::proof() const {
  const ::zksnark::PHGRProof* p = proof_;
  // @@protoc_insertion_point(field_get:zksnark.VerifyRequest.proof)
  return p != NULL ? *p : *reinterpret_cast<const ::zksnark::PHGRProof*>(
      &::zksnark::_PHGRProof_default_instance_);
}
inline ::zksnark::PHGRProof* VerifyRequest::release_proof() {
  // @@protoc_insertion_point(field_release:zksnark.VerifyRequest.proof)
  
  ::zksnark::PHGRProof* temp = proof_;
  proof_ = NULL;
  return temp;
}
inline ::zksnark::PHGRProof* VerifyRequest::mutable_proof() {
  
  if (proof_ == NULL) {
    proof_ = new ::zksnark::PHGRProof;
  }
  // @@protoc_insertion_point(field_mutable:zksnark.VerifyRequest.proof)
  return proof_;
}
inline void VerifyRequest::set_allocated_proof(::zksnark::PHGRProof* proof) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete proof_;
  }
  if (proof) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      proof = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proof, submessage_arena);
    }
    
  } else {
    
  }
  proof_ = proof;
  // @@protoc_insertion_point(field_set_allocated:zksnark.VerifyRequest.proof)
}

// bytes hsig = 2;
inline void VerifyRequest::clear_hsig() {
  hsig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VerifyRequest::hsig() const {
  // @@protoc_insertion_point(field_get:zksnark.VerifyRequest.hsig)
  return hsig_.GetNoArena();
}
inline void VerifyRequest::set_hsig(const ::std::string& value) {
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.VerifyRequest.hsig)
}
#if LANG_CXX11
inline void VerifyRequest::set_hsig(::std::string&& value) {
  
  hsig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.VerifyRequest.hsig)
}
#endif
inline void VerifyRequest::set_hsig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.VerifyRequest.hsig)
}
inline void VerifyRequest::set_hsig(const void* value, size_t size) {
  
  hsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.VerifyRequest.hsig)
}
inline ::std::string* VerifyRequest::mutable_hsig() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.VerifyRequest.hsig)
  return hsig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyRequest::release_hsig() {
  // @@protoc_insertion_point(field_release:zksnark.VerifyRequest.hsig)
  
  return hsig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyRequest::set_allocated_hsig(::std::string* hsig) {
  if (hsig != NULL) {
    
  } else {
    
  }
  hsig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hsig);
  // @@protoc_insertion_point(field_set_allocated:zksnark.VerifyRequest.hsig)
}

// bytes rt = 3;
inline void VerifyRequest::clear_rt() {
  rt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VerifyRequest::rt() const {
  // @@protoc_insertion_point(field_get:zksnark.VerifyRequest.rt)
  return rt_.GetNoArena();
}
inline void VerifyRequest::set_rt(const ::std::string& value) {
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zksnark.VerifyRequest.rt)
}
#if LANG_CXX11
inline void VerifyRequest::set_rt(::std::string&& value) {
  
  rt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zksnark.VerifyRequest.rt)
}
#endif
inline void VerifyRequest::set_rt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zksnark.VerifyRequest.rt)
}
inline void VerifyRequest::set_rt(const void* value, size_t size) {
  
  rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zksnark.VerifyRequest.rt)
}
inline ::std::string* VerifyRequest::mutable_rt() {
  
  // @@protoc_insertion_point(field_mutable:zksnark.VerifyRequest.rt)
  return rt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyRequest::release_rt() {
  // @@protoc_insertion_point(field_release:zksnark.VerifyRequest.rt)
  
  return rt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyRequest::set_allocated_rt(::std::string* rt) {
  if (rt != NULL) {
    
  } else {
    
  }
  rt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rt);
  // @@protoc_insertion_point(field_set_allocated:zksnark.VerifyRequest.rt)
}

// repeated bytes nullifiers = 4;
inline int VerifyRequest::nullifiers_size() const {
  return nullifiers_.size();
}
inline void VerifyRequest::clear_nullifiers() {
  nullifiers_.Clear();
}
inline const ::std::string& VerifyRequest::nullifiers(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.VerifyRequest.nullifiers)
  return nullifiers_.Get(index);
}
inline ::std::string* VerifyRequest::mutable_nullifiers(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.VerifyRequest.nullifiers)
  return nullifiers_.Mutable(index);
}
inline void VerifyRequest::set_nullifiers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zksnark.VerifyRequest.nullifiers)
  nullifiers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void VerifyRequest::set_nullifiers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:zksnark.VerifyRequest.nullifiers)
  nullifiers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void VerifyRequest::set_nullifiers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nullifiers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zksnark.VerifyRequest.nullifiers)
}
inline void VerifyRequest::set_nullifiers(int index, const void* value, size_t size) {
  nullifiers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zksnark.VerifyRequest.nullifiers)
}
inline ::std::string* VerifyRequest::add_nullifiers() {
  // @@protoc_insertion_point(field_add_mutable:zksnark.VerifyRequest.nullifiers)
  return nullifiers_.Add();
}
inline void VerifyRequest::add_nullifiers(const ::std::string& value) {
  nullifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zksnark.VerifyRequest.nullifiers)
}
#if LANG_CXX11
inline void VerifyRequest::add_nullifiers(::std::string&& value) {
  nullifiers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zksnark.VerifyRequest.nullifiers)
}
#endif
inline void VerifyRequest::add_nullifiers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nullifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zksnark.VerifyRequest.nullifiers)
}
inline void VerifyRequest::add_nullifiers(const void* value, size_t size) {
  nullifiers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zksnark.VerifyRequest.nullifiers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VerifyRequest::nullifiers() const {
  // @@protoc_insertion_point(field_list:zksnark.VerifyRequest.nullifiers)
  return nullifiers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VerifyRequest::mutable_nullifiers() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.VerifyRequest.nullifiers)
  return &nullifiers_;
}

// repeated bytes commits = 5;
inline int VerifyRequest::commits_size() const {
  return commits_.size();
}
inline void VerifyRequest::clear_commits() {
  commits_.Clear();
}
inline const ::std::string& VerifyRequest::commits(int index) const {
  // @@protoc_insertion_point(field_get:zksnark.VerifyRequest.commits)
  return commits_.Get(index);
}
inline ::std::string* VerifyRequest::mutable_commits(int index) {
  // @@protoc_insertion_point(field_mutable:zksnark.VerifyRequest.commits)
  return commits_.Mutable(index);
}
inline void VerifyRequest::set_commits(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zksnark.VerifyRequest.commits)
  commits_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void VerifyRequest::set_commits(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:zksnark.VerifyRequest.commits)
  commits_.Mutable(index)->assign(std::move(value));
}
#endif
inline void VerifyRequest::set_commits(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  commits_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zksnark.VerifyRequest.commits)
}
inline void VerifyRequest::set_commits(int index, const void* value, size_t size) {
  commits_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zksnark.VerifyRequest.commits)
}
inline ::std::string* VerifyRequest::add_commits() {
  // @@protoc_insertion_point(field_add_mutable:zksnark.VerifyRequest.commits)
  return commits_.Add();
}
inline void VerifyRequest::add_commits(const ::std::string& value) {
  commits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zksnark.VerifyRequest.commits)
}
#if LANG_CXX11
inline void VerifyRequest::add_commits(::std::string&& value) {
  commits_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zksnark.VerifyRequest.commits)
}
#endif
inline void VerifyRequest::add_commits(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  commits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zksnark.VerifyRequest.commits)
}
inline void VerifyRequest::add_commits(const void* value, size_t size) {
  commits_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zksnark.VerifyRequest.commits)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VerifyRequest::commits() const {
  // @@protoc_insertion_point(field_list:zksnark.VerifyRequest.commits)
  return commits_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VerifyRequest::mutable_commits() {
  // @@protoc_insertion_point(field_mutable_list:zksnark.VerifyRequest.commits)
  return &commits_;
}

// uint64 reward = 6;
inline void VerifyRequest::clear_reward() {
  reward_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 VerifyRequest::reward() const {
  // @@protoc_insertion_point(field_get:zksnark.VerifyRequest.reward)
  return reward_;
}
inline void VerifyRequest::set_reward(::google::protobuf::uint64 value) {
  
  reward_ = value;
  // @@protoc_insertion_point(field_set:zksnark.VerifyRequest.reward)
}

// -------------------------------------------------------------------

// VerifyReply

// bool valid = 1;
inline void VerifyReply::clear_valid() {
  valid_ = false;
}
inline bool VerifyReply::valid() const {
  // @@protoc_insertion_point(field_get:zksnark.VerifyReply.valid)
  return valid_;
}
inline void VerifyReply::set_valid(bool value) {
  
  valid_ = value;
  // @@protoc_insertion_point(field_set:zksnark.VerifyReply.valid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zksnark

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_zksnark_2eproto__INCLUDED
