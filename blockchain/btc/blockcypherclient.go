package btcapi

import (
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"
	"strconv"
	"time"
)
type BlockCypherClient struct {

}
// type of timestamp in blockheader is int64
// const API_KEY = "a2f2bad22feb460482efe5fbbefde77f"
var (
	blockTimestamp int64
	blockHeight    int
)

const (
	MAX_TIMESTAMP = 4762368000
)

func (self *BlockCypherClient)GetNonceByTimestamp(timestamp int64) (int, int64, int64, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	resp, err := http.Get("https://api.blockcypher.com/v1/btc/main")
	if err != nil {
		return 0, 0, -1, err
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusOK {
		chainBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return 0, 0, -1, NewBTCAPIError(UnExpectedError, err)
		}
		chain := make(map[string]interface{})
		json.Unmarshal(chainBytes, &chain)
		chainHeight := int(chain["height"].(float64))
		chainTimestamp, err := makeTimestamp2(chain["time"].(string))
		if err != nil {
			return 0, 0, -1, NewBTCAPIError(UnmashallJsonBlockError, err)
		}
		blockHeight, err := estimateBlockHeight(self, timestamp, chainHeight, chainTimestamp)
		if err != nil {
			return 0, 0, -1, err
		}
		blockTimestamp,_, err = self.GetTimeStampAndNonceByBlockHeight(blockHeight)
		if err != nil {
			return 0, 0, -1, err
		}
		if blockTimestamp == MAX_TIMESTAMP {
			return 0, 0, -1, NewBTCAPIError(APIError, errors.New("Can't get result from API"))
		}
		if blockTimestamp > timestamp {
			for blockTimestamp > timestamp {
				blockHeight--
				blockTimestamp,_, err = self.GetTimeStampAndNonceByBlockHeight(blockHeight)
				if err != nil {
					return 0, 0, -1, err
				}
				if blockTimestamp == MAX_TIMESTAMP {
					return 0, 0, -1, NewBTCAPIError(APIError, errors.New("Can't get result from API"))
				}
				if blockTimestamp <= timestamp {
					blockHeight++
					break
				}
			}
		} else {
			for blockTimestamp <= timestamp {
				blockHeight++
				if blockHeight > chainHeight {
					return 0, 0, -1, NewBTCAPIError(APIError, errors.New("Timestamp is greater than timestamp of highest block"))
				}
				blockTimestamp, _, err = self.GetTimeStampAndNonceByBlockHeight(blockHeight)
				if err != nil {
					return 0, 0, -1, err
				}
				if blockTimestamp == MAX_TIMESTAMP {
					return 0, 0, -1, NewBTCAPIError(APIError, errors.New("Can't get result from API"))
				}
				if blockTimestamp > timestamp {
					break
				}
			}
		}
		timestamp, nonce, err := self.GetTimeStampAndNonceByBlockHeight(blockHeight)
		if err != nil {
			return 0, 0, -1, err
		}
		return blockHeight, timestamp, nonce, nil
	}
	return 0, 0, -1, NewBTCAPIError(NonceError, errors.New("Can't get nonce"))
}

func (self *BlockCypherClient) VerifyNonceWithTimestamp(timestamp int64, nonce int64) (bool, error) {
	_, _, tempNonce, err := self.GetNonceByTimestamp(timestamp)
	if err != nil {
		return false, err
	}
	return tempNonce == nonce, nil
}

func (self *BlockCypherClient) GetCurrentChainTimeStamp() (int64, error) {
	resp, err := http.Get("https://api.blockcypher.com/v1/btc/main")
	if err != nil {
		return -1, err
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusOK {
		chainBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return -1, err
		}
		chain := make(map[string]interface{})
		json.Unmarshal(chainBytes, &chain)
		chainTimestamp, err := makeTimestamp2(chain["time"].(string))
		return chainTimestamp, nil
	}
	return -1, errors.New("API error")
}

//true for nonce, false for time
// return param:
// #param 1: timestamp -> flag false
// #param 2: nonce -> flag true
func (self *BlockCypherClient) GetTimeStampAndNonceByBlockHeight(blockHeight int) (int64, int64, error) {
	time.Sleep(1 * time.Second)
	resp, err := http.Get("https://api.blockcypher.com/v1/btc/main/blocks/" + strconv.Itoa(blockHeight) + "?start=1&limit=1")
	if err != nil {
		return -1, MAX_TIMESTAMP, NewBTCAPIError(APIError, err)
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusOK {
		blockBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return -1, MAX_TIMESTAMP, NewBTCAPIError(UnExpectedError, err)
		}
		block := make(map[string]interface{})
		err = json.Unmarshal(blockBytes, &block)
		if err != nil {
			return -1, MAX_TIMESTAMP, NewBTCAPIError(UnmashallJsonBlockError, errors.New("Can't get nonce or timestamp"))
		}
		nonce := int64(block["nonce"].(float64))
		timeTime, err := time.Parse(time.RFC3339, block["time"].(string))
		if err != nil {
			return -1, MAX_TIMESTAMP, NewBTCAPIError(UnExpectedError, err)
		}
		timeInt64 := makeTimestamp(timeTime)
		return nonce, timeInt64, nil
	}
	return -1, MAX_TIMESTAMP, NewBTCAPIError(UnExpectedError, errors.New("Can't get nonce or timestamp"))
}
