package btcapi

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"time"
)

// type of timestamp in blockheader is int64
// const API_KEY = "a2f2bad22feb460482efe5fbbefde77f"
var (
	blockTimestamp int64
	blockHeight    int
)

const (
	MAX_TIMESTAMP = 4762368000
)

func GetNonceByTimestamp(timestamp int64) (int64, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	resp, err := http.Get("https://api.blockcypher.com/v1/btc/test3")
	if err != nil {
		return -1, err
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusOK {
		chainBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return -1, err
		}
		chain := make(map[string]interface{})
		json.Unmarshal(chainBytes, &chain)
		chainHeight := int(chain["height"].(float64))
		blockHeight = int(chain["height"].(float64))
		// TODO: 0xmerman calculate timestamp to get the right nonce
		// get list of block with timestamp > given timestamp then get block with min timestamp value
		_, blockTimestamp, err = GetNonceOrTimeStampByBlock(strconv.Itoa(blockHeight), false)
		if err != nil {
			fmt.Println(err)
			return -1, err
		}
		if blockTimestamp == MAX_TIMESTAMP {
			return -1, errors.New("API error")
		}
		// fmt.Println("BlockTimestamp 1", blockTimestamp, blockHeight, timestamp)
		if blockTimestamp > timestamp {
			for blockTimestamp > timestamp {
				// fmt.Println("BlockTimestamp 2", blockTimestamp, blockHeight, timestamp)
				blockHeight--
				_, blockTimestamp, err = GetNonceOrTimeStampByBlock(strconv.Itoa(blockHeight), false)
				if err != nil {
					fmt.Println(err)
					return -1, err
				}
				if blockTimestamp == MAX_TIMESTAMP {
					return -1, errors.New("API error")
				}
				if blockTimestamp <= timestamp {
					// fmt.Println("BlockTimestamp 2-2", blockTimestamp, blockHeight, timestamp)
					blockHeight++
					break
				}
			}
		} else {
			for blockTimestamp <= timestamp {
				// fmt.Println("BlockTimestamp 3", blockTimestamp, blockHeight, timestamp)
				blockHeight++
				if blockHeight > chainHeight {
					return -1, errors.New("Timestamp is greater than timestamp of highest block")
				}
				_, blockTimestamp, err = GetNonceOrTimeStampByBlock(strconv.Itoa(blockHeight), false)
				if err != nil {
					fmt.Println(err)
					return -1, err
				}
				if blockTimestamp == MAX_TIMESTAMP {
					return -1, errors.New("API error")
				}
				if blockTimestamp > timestamp {
					break
				}
			}
		}
		fmt.Println("blockHeight", blockHeight)
		nonce, _, err := GetNonceOrTimeStampByBlock(strconv.Itoa(blockHeight), true)
		fmt.Println("Nonce", nonce)
		if err != nil {
			return -1, err
		}
		// common.Logger.Infof("Found nonce %d match timestamp %d", nonce, timestamp)
		return nonce, nil
	}
	return -1, errors.New("ERROR Getting Nonce By Timestamp Bitcoin")
}

//true for nonce, false for time
// return param:
// #param 1: nonce -> flag true
// #param 2: timestamp -> flag false
func GetNonceOrTimeStampByBlock(blockHeight string, nonceOrTime bool) (int64, int64, error) {
	resp, err := http.Get("https://api.blockcypher.com/v1/btc/test3/blocks/" + blockHeight + "?start=1&limit=1")
	if err != nil {
		return -1, MAX_TIMESTAMP, err
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusOK {
		blockBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return -1, MAX_TIMESTAMP, err
		}
		block := make(map[string]interface{})
		json.Unmarshal(blockBytes, &block)
		if nonceOrTime {
			return int64(block["nonce"].(float64)), -1, nil
		} else {
			timeTime, err := time.Parse(time.RFC3339, block["time"].(string))
			if err != nil {
				return -1, MAX_TIMESTAMP, err
			}
			timeInt64 := makeTimestamp(timeTime)
			return -1, timeInt64, nil
		}
	}
	return -1, MAX_TIMESTAMP, errors.New("ERROR Getting Nonce or Timestamp from Bitcoin")
}

// count in second
// use t.UnixNano() / int64(time.Millisecond) for milisecond
func makeTimestamp(t time.Time) int64 {
	return t.Unix()
}
